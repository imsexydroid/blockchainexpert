{"uid":"solidity-fundamentals-assessment","name":"Solidity Fundamentals Assessment","questions":[{"acl":{"isAvailable":true,"isFree":false,"isFreeForStudents":false,"productRequired":["blockchainexpert"]},"category":"Solidity","contents":{"acl":{"isAvailable":true,"isFree":false,"isFreeForStudents":false,"productRequired":["blockchainexpert"]},"assessmentSummary":null,"category":"Solidity","changelog":[],"customInputVars":[],"difficulty":0,"hints":[],"isLongOutput":false,"isSlowExecution":false,"jsonTests":[],"languagesSupported":["solidity"],"name":"Advanced Counter","notes":"","prompt":"\u003cdiv class=\"html\"\u003e\n  \u003cp\u003e\n    Write a smart contract named \u003cspan\u003eAdvancedCounter\u003c/span\u003e that allows\n    multiple users to keep track of their own independent counters. Each counter\n    will be represented by a \u003cspan\u003estring\u003c/span\u003e id and will be specific to each\n    user/account that interacts with the smart contract. Each user should have a\n    limit of \u003cspan\u003e3\u003c/span\u003e counters. Each counter should store an\n    \u003cspan\u003eint\u003c/span\u003e value.\n  \u003c/p\u003e\n  \u003cp\u003e\n    For example, account with address \u003cspan\u003e0xabc...\u003c/span\u003e may have three\n    counters with ids \u003cspan\u003e\"a\"\u003c/span\u003e, \u003cspan\u003e\"b\"\u003c/span\u003e, \u003cspan\u003e\"c\"\u003c/span\u003e. Each\n    counter should be able to be manipulated independently of all other counters\n    by using the functions below. To clarify, if another address, say\n    \u003cspan\u003e0xbbb...\u003c/span\u003e, had a counter with id \u003cspan\u003e\"a\"\u003c/span\u003e this would be\n    a separate counter from the counter with id \u003cspan\u003e\"a\"\u003c/span\u003e that is\n    controlled by \u003cspan\u003e0xabc...\u003c/span\u003e. Each address should only be able to\n    control their own counters.\n  \u003c/p\u003e\n  \u003cp\u003eTo write this smart contract implement the functions defined below.\u003c/p\u003e\n  \u003cul\u003e\n    \u003cli\u003e\n      \u003cspan\u003ecreateCounter(string id, int value)\u003c/span\u003e: this function should set\n      the counter with the passed \u003cspan\u003eid\u003c/span\u003e to that passed\n      \u003cspan\u003evalue\u003c/span\u003e for the address that called this function. This\n      function should fail if the user already has \u003cspan\u003e3\u003c/span\u003e counters (the\n      maximum allowed) or if the passed counter \u003cspan\u003eid\u003c/span\u003e already exists\n      for this user.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003edeleteCounter(string id)\u003c/span\u003e: this function should delete the\n      counter with the passed \u003cspan\u003eid\u003c/span\u003e for the address that called this\n      function. After the deletion the address should be able to create another\n      counter with the same or a new id. This function should fail if called\n      with an \u003cspan\u003eid\u003c/span\u003e for a counter that does not exist.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003eincrementCounter(string id)\u003c/span\u003e: this function should increment\n      the counter with the passed \u003cspan\u003eid\u003c/span\u003e by \u003cspan\u003e1\u003c/span\u003e for the\n      address that called this function. This function should fail if called\n      with an \u003cspan\u003eid\u003c/span\u003e for a counter that does not exist (i.e., it has not\n      been created yet or it was deleted).\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003edecrementCounter(string id)\u003c/span\u003e: this function should decrement\n      the counter with the passed \u003cspan\u003eid\u003c/span\u003e by \u003cspan\u003e1\u003c/span\u003e for the\n      address that called this function. This function should fail if called\n      with an \u003cspan\u003eid\u003c/span\u003e for a counter that does not exist (i.e., it has not\n      been created yet or it was deleted).\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003egetCount(string id)\u003c/span\u003e: this function should return the value of\n      the counter with the passed \u003cspan\u003eid\u003c/span\u003e for the address that called\n      this function. This function should fail if called with an\n      \u003cspan\u003eid\u003c/span\u003e for a counter that does not exist (i.e., it has not been\n      created yet or it was deleted).\n    \u003c/li\u003e\n  \u003c/ul\u003e\n  \u003cp\u003e\n    You are welcome to create any additional functions and use as many storage\n    variables as you deem necessary.\n  \u003c/p\u003e\n\u003c/div\u003e","releaseDate":"2022-05-24T00:00:00Z","resources":{"solidity":{"language":"solidity","sandboxCode":"// This suite of tests is written to run against your code\n// so that we can check its correctness.\n\nconst { assert } = require(\"chai\");\n\nconst AdvancedCounter = artifacts.require(\"AdvancedCounter\");\n\ncontract(\"AdvancedCounter\", (accounts) =\u003e {\n  let instance;\n  const owner = accounts[0];\n  const acc1 = accounts[1];\n  const acc2 = accounts[2];\n  const acc3 = accounts[3];\n\n  before(async () =\u003e {\n    instance = await AdvancedCounter.deployed({ from: owner });\n  });\n\n  it(\"cannot delete counter that does not exist\", async () =\u003e {\n    try {\n      await instance.deleteCounter(\"a\");\n      assert.ok(\n        false,\n        \"deleteCounter() should fail when called with an id that doesn't exist\"\n      );\n    } catch {\n      return;\n    }\n  });\n\n  it(\"cannot increment counter that does not exist\", async () =\u003e {\n    try {\n      await instance.incrementCounter(\"a\");\n      assert.ok(\n        false,\n        \"incrementCounter() should fail when called with an id that doesn't exist\"\n      );\n    } catch {\n      return;\n    }\n  });\n\n  it(\"cannot decrement counter that does not exist\", async () =\u003e {\n    try {\n      await instance.decrementCounter(\"a\");\n      assert.ok(\n        false,\n        \"decrementCounter() should fail when called with an id that doesn't exist\"\n      );\n    } catch {\n      return;\n    }\n  });\n\n  it(\"cannot get count that does not exist\", async () =\u003e {\n    try {\n      await instance.getCount(\"a\");\n      assert.ok(\n        false,\n        \"getCount() should fail when called with an id that doesn't exist\"\n      );\n    } catch {\n      return;\n    }\n  });\n\n  it(\"acc1 can create a counter\", async () =\u003e {\n    await instance.createCounter(\"a\", 10, { from: acc1 });\n    const result = await instance.getCount(\"a\", { from: acc1 });\n    assert.equal(10, result, `counter with id a for account acc1 should be 10`);\n  });\n\n  it(\"acc2 can create a counter\", async () =\u003e {\n    await instance.createCounter(\"a\", 20, { from: acc2 });\n    const result = await instance.getCount(\"a\", { from: acc2 });\n    assert.equal(20, result, `counter with id a for account acc2 should be 20`);\n\n    const result2 = await instance.getCount(\"a\", { from: acc1 });\n    assert.equal(\n      10,\n      result2,\n      `counter with id a for account acc1 should be 10`\n    );\n  });\n\n  it(\"acc1 can increment a counter\", async () =\u003e {\n    await instance.incrementCounter(\"a\", { from: acc1 });\n    const result = await instance.getCount(\"a\", { from: acc1 });\n    assert.equal(11, result, `counter with id a for account acc1 should be 11`);\n\n    const result2 = await instance.getCount(\"a\", { from: acc2 });\n    assert.equal(\n      20,\n      result2,\n      `counter with id a for account acc2 should be 20`\n    );\n  });\n\n  it(\"acc1 can decrement a counter\", async () =\u003e {\n    await instance.decrementCounter(\"a\", { from: acc1 });\n    const result = await instance.getCount(\"a\", { from: acc1 });\n    assert.equal(10, result, `counter with id a for account acc1 should be 10`);\n\n    const result2 = await instance.getCount(\"a\", { from: acc2 });\n    assert.equal(\n      20,\n      result2,\n      `counter with id a for account acc2 should be 20`\n    );\n  });\n\n  it(\"acc1 can delete a counter\", async () =\u003e {\n    try {\n      await instance.deleteCounter(\"a\", { from: acc1 });\n    } catch {\n      assert.ok(false, \"deleteCounter() should delete counter\");\n    }\n\n    try {\n      await instance.getCount(\"a\", { from: acc1 });\n      assert.ok(\n        false,\n        \"getCount() should fail when called with an id that doesn't exist\"\n      );\n    } catch {}\n\n    const result2 = await instance.getCount(\"a\", { from: acc2 });\n    assert.equal(\n      20,\n      result2,\n      `counter with id a for account acc2 should be 20`\n    );\n  });\n\n  it(\"acc3 can create 3 counters\", async () =\u003e {\n    await instance.createCounter(\"1\", 1, { from: acc3 });\n    const result = await instance.getCount(\"1\", { from: acc3 });\n    assert.equal(1, result, `counter with id 1 for account acc3 should be 1`);\n\n    await instance.createCounter(\"2\", -1, { from: acc3 });\n    const result2 = await instance.getCount(\"2\", { from: acc3 });\n    assert.equal(\n      -1,\n      result2,\n      `counter with id 2 for account acc3 should be -1`\n    );\n\n    await instance.createCounter(\"3\", 100, { from: acc3 });\n    const result3 = await instance.getCount(\"3\", { from: acc3 });\n    assert.equal(\n      100,\n      result3,\n      `counter with id 3 for account acc3 should be 100`\n    );\n  });\n\n  it(\"acc3 can manipulate counters independently \", async () =\u003e {\n    await instance.incrementCounter(\"1\", { from: acc3 });\n    const result = await instance.getCount(\"1\", { from: acc3 });\n    assert.equal(2, result, `counter with id 1 for account acc3 should be 2`);\n\n    const result2 = await instance.getCount(\"2\", { from: acc3 });\n    assert.equal(\n      -1,\n      result2,\n      `counter with id 2 for account acc3 should be -1`\n    );\n\n    const result3 = await instance.getCount(\"3\", { from: acc3 });\n    assert.equal(\n      100,\n      result3,\n      `counter with id 3 for account acc3 should be 100`\n    );\n  });\n\n  it(\"acc3 cannot create a 4th counter\", async () =\u003e {\n    try {\n      await instance.createCounter(\"4\", 1, { from: acc3 });\n      assert.ok(false, \"acc3 should not be able to create a 4th counter\");\n    } catch {\n      return;\n    }\n  });\n\n  it(\"acc3 cannot create another counter after deleting a counter\", async () =\u003e {\n    try {\n      await instance.deleteCounter(\"3\", { from: acc3 });\n    } catch {\n      assert.ok(false, \"deleteCounter() should delete counter\");\n    }\n\n    await instance.createCounter(\"4\", 50, { from: acc3 });\n    const result = await instance.getCount(\"4\", { from: acc3 });\n    assert.equal(50, result, `counter with id 4 for account acc3 should be 50`);\n  });\n});\n","solutions":["// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npragma solidity \u003e=0.4.22 \u003c=0.8.17;\n\ncontract AdvancedCounter {\n    mapping(address =\u003e mapping(string =\u003e int256)) counters;\n    mapping(address =\u003e mapping(string =\u003e bool)) counterIdExists; // required to keep track of used ids\n    mapping(address =\u003e uint256) numCountersCreated; // required to keep track of number of counters\n\n    function counterExists(string memory id) internal view returns (bool) {\n        // it is not neccessary to write this function but it helps keep the code more readable\n        return counterIdExists[msg.sender][id];\n    }\n\n    function createCounter(string memory id, int256 value) public {\n        require(\n            numCountersCreated[msg.sender] != 3,\n            \"you have already created the maximum number of counters\"\n        );\n        require(!counterExists(id), \"a counter with this id already exists\");\n        counters[msg.sender][id] = value;\n        numCountersCreated[msg.sender]++;\n        counterIdExists[msg.sender][id] = true;\n    }\n\n    function deleteCounter(string memory id) public {\n        require(counterExists(id), \"this counter does not exist\");\n        delete counters[msg.sender][id];\n        numCountersCreated[msg.sender]--;\n        counterIdExists[msg.sender][id] = false;\n    }\n\n    function incrementCounter(string memory id) public {\n        require(counterExists(id), \"this counter does not exist\");\n        counters[msg.sender][id]++;\n    }\n\n    function decrementCounter(string memory id) public {\n        require(counterExists(id), \"this counter does not exist\");\n        counters[msg.sender][id]--;\n    }\n\n    function getCount(string memory id) public view returns (int256) {\n        require(counterExists(id), \"this counter does not exist\");\n        return counters[msg.sender][id];\n    }\n}\n"],"solutionsDisabled":false,"startingCode":"pragma solidity \u003e=0.4.22 \u003c=0.8.17;\n\ncontract AdvancedCounter {\n    function createCounter(string memory id, int256 value) public {\n        // Write your code here\n    }\n\n    function deleteCounter(string memory id) public {\n        // Write your code here\n    }\n\n    function incrementCounter(string memory id) public {\n        // Write your code here\n    }\n\n    function decrementCounter(string memory id) public {\n        // Write your code here\n    }\n\n    function getCount(string memory id) public view returns (int256) {\n        // Write your code here\n    }\n}\n","unitTests":"const { assert } = require(\"chai\");\n\nconst AdvancedCounter = artifacts.require(\"AdvancedCounter\");\n\ncontract(\"AdvancedCounter\", (accounts) =\u003e {\n  let instance;\n  const owner = accounts[0];\n  const acc1 = accounts[1];\n  const acc2 = accounts[2];\n  const acc3 = accounts[3];\n\n  before(async () =\u003e {\n    instance = await AdvancedCounter.deployed({ from: owner });\n  });\n\n  it(\"cannot delete counter that does not exist\", async () =\u003e {\n    try {\n      await instance.deleteCounter(\"a\");\n      assert.ok(\n        false,\n        \"deleteCounter() should fail when called with an id that doesn't exist\"\n      );\n    } catch {\n      return;\n    }\n  });\n\n  it(\"cannot increment counter that does not exist\", async () =\u003e {\n    try {\n      await instance.incrementCounter(\"a\");\n      assert.ok(\n        false,\n        \"incrementCounter() should fail when called with an id that doesn't exist\"\n      );\n    } catch {\n      return;\n    }\n  });\n\n  it(\"cannot decrement counter that does not exist\", async () =\u003e {\n    try {\n      await instance.decrementCounter(\"a\");\n      assert.ok(\n        false,\n        \"decrementCounter() should fail when called with an id that doesn't exist\"\n      );\n    } catch {\n      return;\n    }\n  });\n\n  it(\"cannot get count that does not exist\", async () =\u003e {\n    try {\n      await instance.getCount(\"a\");\n      assert.ok(\n        false,\n        \"getCount() should fail when called with an id that doesn't exist\"\n      );\n    } catch {\n      return;\n    }\n  });\n\n  it(\"acc1 can create a counter\", async () =\u003e {\n    await instance.createCounter(\"a\", 10, { from: acc1 });\n    const result = await instance.getCount(\"a\", { from: acc1 });\n    assert.equal(10, result, `counter with id a for account acc1 should be 10`);\n  });\n\n  it(\"acc2 can create a counter\", async () =\u003e {\n    await instance.createCounter(\"a\", 20, { from: acc2 });\n    const result = await instance.getCount(\"a\", { from: acc2 });\n    assert.equal(20, result, `counter with id a for account acc2 should be 20`);\n\n    const result2 = await instance.getCount(\"a\", { from: acc1 });\n    assert.equal(\n      10,\n      result2,\n      `counter with id a for account acc1 should be 10`\n    );\n  });\n\n  it(\"acc1 can increment a counter\", async () =\u003e {\n    await instance.incrementCounter(\"a\", { from: acc1 });\n    const result = await instance.getCount(\"a\", { from: acc1 });\n    assert.equal(11, result, `counter with id a for account acc1 should be 11`);\n\n    const result2 = await instance.getCount(\"a\", { from: acc2 });\n    assert.equal(\n      20,\n      result2,\n      `counter with id a for account acc2 should be 20`\n    );\n  });\n\n  it(\"acc1 can decrement a counter\", async () =\u003e {\n    await instance.decrementCounter(\"a\", { from: acc1 });\n    const result = await instance.getCount(\"a\", { from: acc1 });\n    assert.equal(10, result, `counter with id a for account acc1 should be 10`);\n\n    const result2 = await instance.getCount(\"a\", { from: acc2 });\n    assert.equal(\n      20,\n      result2,\n      `counter with id a for account acc2 should be 20`\n    );\n  });\n\n  it(\"acc1 can delete a counter\", async () =\u003e {\n    try {\n      await instance.deleteCounter(\"a\", { from: acc1 });\n    } catch {\n      assert.ok(false, \"deleteCounter() should delete counter\");\n    }\n\n    try {\n      await instance.getCount(\"a\", { from: acc1 });\n      assert.ok(\n        false,\n        \"getCount() should fail when called with an id that doesn't exist\"\n      );\n    } catch {}\n\n    const result2 = await instance.getCount(\"a\", { from: acc2 });\n    assert.equal(\n      20,\n      result2,\n      `counter with id a for account acc2 should be 20`\n    );\n  });\n\n  it(\"acc3 can create 3 counters\", async () =\u003e {\n    await instance.createCounter(\"1\", 1, { from: acc3 });\n    const result = await instance.getCount(\"1\", { from: acc3 });\n    assert.equal(1, result, `counter with id 1 for account acc3 should be 1`);\n\n    await instance.createCounter(\"2\", -1, { from: acc3 });\n    const result2 = await instance.getCount(\"2\", { from: acc3 });\n    assert.equal(\n      -1,\n      result2,\n      `counter with id 2 for account acc3 should be -1`\n    );\n\n    await instance.createCounter(\"3\", 100, { from: acc3 });\n    const result3 = await instance.getCount(\"3\", { from: acc3 });\n    assert.equal(\n      100,\n      result3,\n      `counter with id 3 for account acc3 should be 100`\n    );\n  });\n\n  it(\"acc3 can manipulate counters independently \", async () =\u003e {\n    await instance.incrementCounter(\"1\", { from: acc3 });\n    const result = await instance.getCount(\"1\", { from: acc3 });\n    assert.equal(2, result, `counter with id 1 for account acc3 should be 2`);\n\n    const result2 = await instance.getCount(\"2\", { from: acc3 });\n    assert.equal(\n      -1,\n      result2,\n      `counter with id 2 for account acc3 should be -1`\n    );\n\n    const result3 = await instance.getCount(\"3\", { from: acc3 });\n    assert.equal(\n      100,\n      result3,\n      `counter with id 3 for account acc3 should be 100`\n    );\n  });\n\n  it(\"acc3 cannot create a 4th counter\", async () =\u003e {\n    try {\n      await instance.createCounter(\"4\", 1, { from: acc3 });\n      assert.ok(false, \"acc3 should not be able to create a 4th counter\");\n    } catch {\n      return;\n    }\n  });\n\n  it(\"acc3 cannot create another counter after deleting a counter\", async () =\u003e {\n    try {\n      await instance.deleteCounter(\"3\", { from: acc3 });\n    } catch {\n      assert.ok(false, \"deleteCounter() should delete counter\");\n    }\n\n    await instance.createCounter(\"4\", 50, { from: acc3 });\n    const result = await instance.getCount(\"4\", { from: acc3 });\n    assert.equal(50, result, `counter with id 4 for account acc3 should be 50`);\n  });\n});\n"}},"spaceTime":"","submissionStatistics":{"correctCount":398,"failureCount":1220},"testStrategy":"SANDBOX_ONLY","tests":[],"uid":"advanced-counter","version":0,"video":{"annotations":[],"codeWalkthroughTime":null,"duration":0,"instructor":"","overviewTime":null,"vimeoId":"765856854"},"visualization":{"inputType":null,"outputType":null}},"difficulty":0,"instructor":"","name":"Advanced Counter","releaseDate":"2022-05-24T00:00:00Z","type":"CODING_STANDARD","uid":"advanced-counter"},{"acl":{"isAvailable":true,"isFree":false,"isFreeForStudents":false,"productRequired":["blockchainexpert"]},"category":"Solidity","contents":{"acl":{"isAvailable":true,"isFree":false,"isFreeForStudents":false,"productRequired":["blockchainexpert"]},"assessmentSummary":null,"category":"Solidity","changelog":[],"customInputVars":[],"difficulty":0,"hints":[],"isLongOutput":false,"isSlowExecution":false,"jsonTests":[],"languagesSupported":["solidity"],"name":"Greedy Banker","notes":"","prompt":"\u003cdiv class=\"html\"\u003e\n  \u003cp\u003e\n    Write a smart contract named \u003cspan\u003eGreedyBanker\u003c/span\u003e that acts as a bank\n    account for users. It should allow users to deposit funds by sending ether\n    directly to the contract address via the \u003cspan\u003ereceive\u003c/span\u003e function and\n    to withdraw their funds using a function you'll implement named\n    \u003cspan\u003ewithdraw\u003c/span\u003e. The catch is, the deployer of this smart contract is\n    greedy and wants to collect a fee from users when they make a deposit.\n  \u003c/p\u003e\n  \u003cp\u003e\n    Each address that deposits to the smart contract should get exactly one free\n    deposit, afterwards a fee of \u003cspan\u003e1000 wei\u003c/span\u003e should be charged for\n    each deposit. The fees collected by this smart contract should be stored\n    such that the owner can withdraw/collect them at their convenience. If a\n    user has used up their free deposit and attempts to send less money than\n    \u003cspan\u003e1000 wei\u003c/span\u003e (the fee) their deposit should fail. All of this logic\n    should be handled in the \u003cspan\u003ereceive\u003c/span\u003e function.\n  \u003c/p\u003e\n  \u003cp\u003e\n    If a user incorrectly sends funds (i.e., the transaction triggers the\n    \u003cspan\u003efallback\u003c/span\u003e function), all the funds received should be added to\n    the current fees collected and become withdrawable by the owner/deployer of\n    the contract.\n  \u003c/p\u003e\n  \u003cp\u003e\n    As well as the functionality listed above, implement the following\n    functions.\n  \u003c/p\u003e\n  \u003cul\u003e\n    \u003cli\u003e\n      \u003cspan\u003ewithdraw(uint amount)\u003c/span\u003e: a function that allows users to\n      withdraw funds. Assuming the amount they request to withdraw is valid they\n      should be sent that amount. If the user attempts to withdraw more funds\n      then they have available this function should fail. Withdrawls are free\n      (i.e. they don't cost the user a fee).\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003egetBalance()\u003c/span\u003e: a function that returns the callers current\n      withdrawable balance.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003ecollectFees()\u003c/span\u003e: a function that can only be called by the\n      deployer/owner of the smart contract. This function should send the owner\n      all received fees. Make sure this function is not exploitable.\n    \u003c/li\u003e\n  \u003c/ul\u003e\n  \u003cp\u003e\n    Recall, every deposit costs the user \u003cspan\u003e1000 wei\u003c/span\u003e, make sure to\n    adjust the users balance correctly to handle these fees.\n  \u003c/p\u003e\n  \u003cp\u003e\n    Note: Make sure to protect againt re-entrance attacks and other smart\n    contract exploits.\n  \u003c/p\u003e\n\u003c/div\u003e","releaseDate":"2022-05-24T00:00:00Z","resources":{"solidity":{"language":"solidity","sandboxCode":"// This suite of tests is written to run against your code\n// so that we can check its correctness.\n\nconst { assert } = require(\"chai\");\n\nconst GreedyBanker = artifacts.require(\"GreedyBanker\");\n\ncontract(\"GreedyBanker\", (accounts) =\u003e {\n  let instance;\n  const owner = accounts[0];\n  const acc1 = accounts[1];\n  const acc2 = accounts[2];\n\n  before(async () =\u003e {\n    instance = await GreedyBanker.deployed({ from: owner });\n  });\n\n  it(\"acc1 can deposit for free with value less than the fee\", async () =\u003e {\n    await instance.sendTransaction({ from: acc1, value: 500 });\n    const balance = await instance.getBalance({ from: acc1 });\n    assert.equal(500, balance, \"acc1 balance should be 500\");\n  });\n\n  it(\"acc1 can deposit with fee\", async () =\u003e {\n    await instance.sendTransaction({ from: acc1, value: 1100 });\n    const balance = await instance.getBalance({ from: acc1 });\n    assert.equal(600, balance, \"acc1 balance should be 600\");\n  });\n\n  it(\"acc1 cannot deposit less than fee\", async () =\u003e {\n    try {\n      await instance.sendTransaction({ from: acc1, value: 999 });\n      assert.ok(false, \"depositing less than fee should fail\");\n    } catch {}\n    const balance = await instance.getBalance({ from: acc1 });\n    assert.equal(600, balance, \"acc1 balance should be 600\");\n  });\n\n  it(\"acc1 can withdraw partial balance\", async () =\u003e {\n    await instance.withdraw(100, { from: acc1 });\n    const balance = await instance.getBalance({ from: acc1 });\n    assert.equal(500, balance, \"acc1 balance should be 600\");\n\n    assert.equal(\n      1500,\n      await web3.eth.getBalance(instance.address),\n      \"smart contract balance should be 1500 after withdraw\"\n    );\n  });\n\n  it(\"acc1 can withdraw full balance\", async () =\u003e {\n    await instance.withdraw(500, { from: acc1 });\n    const balance = await instance.getBalance({ from: acc1 });\n    assert.equal(0, balance, \"acc1 balance should be 0\");\n\n    assert.equal(\n      1000,\n      await web3.eth.getBalance(instance.address),\n      \"smart contract balance should be 1000 after withdraw\"\n    );\n  });\n\n  it(\"acc1 cannot withdraw more than balance\", async () =\u003e {\n    try {\n      await instance.withdraw(1, { from: acc1 });\n      assert.ok(false, \"withdraw() should fail\");\n    } catch {}\n\n    assert.equal(\n      1000,\n      await web3.eth.getBalance(instance.address),\n      \"smart contract balance should be 1000 after withdraw\"\n    );\n  });\n\n  it(\"acc1 cannot colllect fees\", async () =\u003e {\n    try {\n      await instance.collectFees({ from: acc1 });\n      assert.ok(false, \"collectFees() should fail\");\n    } catch {}\n\n    assert.equal(\n      1000,\n      await web3.eth.getBalance(instance.address),\n      \"smart contract balance should be 1000 after withdraw\"\n    );\n  });\n\n  it(\"owner can collect fees\", async () =\u003e {\n    try {\n      await instance.collectFees({ from: owner });\n    } catch {\n      assert.ok(false, \"collectFees() should be successful\");\n    }\n\n    assert.equal(\n      0,\n      await web3.eth.getBalance(instance.address),\n      \"smart contract balance should be 1000 after withdraw\"\n    );\n  });\n\n  it(\"sending funds incorrectly adds to fees\", async () =\u003e {\n    const data = web3.eth.abi.encodeFunctionSignature({ name: '_maxTxAmount', type: 'function', inputs: [] });\n    await instance.sendTransaction({ from: acc2, value: 1100, data: data });\n    const balance = await instance.getBalance({ from: acc2 });\n    assert.equal(0, balance, \"acc2 balance should be 0\");\n\n    assert.equal(\n      1100,\n      await web3.eth.getBalance(instance.address),\n      \"smart contract balance should be 1100 after fallback()\"\n    );\n  });\n\n  it(\"owner can collect fees\", async () =\u003e {\n    try {\n      await instance.collectFees({ from: owner });\n    } catch {\n      assert.ok(false, \"collectFees() should be successful\");\n    }\n\n    assert.equal(\n      0,\n      await web3.eth.getBalance(instance.address),\n      \"smart contract balance should be 1000 after withdraw\"\n    );\n  });\n});\n","solutions":["// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npragma solidity \u003e=0.4.22 \u003c=0.8.17;\n\ncontract GreedyBanker {\n    uint256 constant fee = 1000 wei;\n\n    mapping(address =\u003e uint256) balances;\n    mapping(address =\u003e uint256) depositCount;\n\n    uint256 feesCollected;\n\n    address owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    receive() external payable {\n        uint256 depositFee;\n        if (depositCount[msg.sender] \u003e= 1) {\n            require(msg.value \u003e= fee, \"amount is not enough to cover the fee\");\n            depositFee = fee;\n        }\n\n        balances[msg.sender] += msg.value - depositFee;\n        feesCollected += depositFee;\n        depositCount[msg.sender]++;\n    }\n\n    fallback() external payable {\n        feesCollected += msg.value;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(balances[msg.sender] \u003e= amount, \"insufficient balance\");\n        balances[msg.sender] -= amount;\n        (bool sent, ) = payable(msg.sender).call{value: amount}(\"\");\n        require(sent, \"withdraw failed\");\n    }\n\n    function collectFees() external {\n        require(msg.sender == owner, \"only the owner can call this function\");\n        uint256 totalFees = feesCollected;\n        feesCollected = 0;\n        (bool sent, ) = payable(owner).call{value: totalFees}(\"\");\n        require(sent, \"transfer failed\");\n    }\n\n    function getBalance() public view returns (uint256) {\n        return balances[msg.sender];\n    }\n}\n"],"solutionsDisabled":false,"startingCode":"pragma solidity \u003e=0.4.22 \u003c=0.8.17;\n\ncontract GreedyBanker {\n    receive() external payable {\n        // Write your code here\n    }\n\n    fallback() external payable {\n        // Write your code here\n    }\n\n    function withdraw(uint256 amount) external {\n        // Write your code here\n    }\n\n    function collectFees() external {\n        // Write your code here\n    }\n\n    function getBalance() public view returns (uint256) {\n        // Write your code here\n    }\n}\n","unitTests":"const { assert } = require(\"chai\");\n\nconst GreedyBanker = artifacts.require(\"GreedyBanker\");\n\ncontract(\"GreedyBanker\", (accounts) =\u003e {\n  let instance;\n  const owner = accounts[0];\n  const acc1 = accounts[1];\n  const acc2 = accounts[2];\n\n  before(async () =\u003e {\n    instance = await GreedyBanker.deployed({ from: owner });\n  });\n\n  it(\"acc1 can deposit for free with value less than the fee\", async () =\u003e {\n    await instance.sendTransaction({ from: acc1, value: 500 });\n    const balance = await instance.getBalance({ from: acc1 });\n    assert.equal(500, balance, \"acc1 balance should be 500\");\n  });\n\n  it(\"acc1 can deposit with fee\", async () =\u003e {\n    await instance.sendTransaction({ from: acc1, value: 1100 });\n    const balance = await instance.getBalance({ from: acc1 });\n    assert.equal(600, balance, \"acc1 balance should be 600\");\n  });\n\n  it(\"acc1 cannot deposit less than fee\", async () =\u003e {\n    try {\n      await instance.sendTransaction({ from: acc1, value: 999 });\n      assert.ok(false, \"depositing less than fee should fail\");\n    } catch {}\n    const balance = await instance.getBalance({ from: acc1 });\n    assert.equal(600, balance, \"acc1 balance should be 600\");\n  });\n\n  it(\"acc1 can withdraw partial balance\", async () =\u003e {\n    await instance.withdraw(100, { from: acc1 });\n    const balance = await instance.getBalance({ from: acc1 });\n    assert.equal(500, balance, \"acc1 balance should be 600\");\n\n    assert.equal(\n      1500,\n      await web3.eth.getBalance(instance.address),\n      \"smart contract balance should be 1500 after withdraw\"\n    );\n  });\n\n  it(\"acc1 can withdraw full balance\", async () =\u003e {\n    await instance.withdraw(500, { from: acc1 });\n    const balance = await instance.getBalance({ from: acc1 });\n    assert.equal(0, balance, \"acc1 balance should be 0\");\n\n    assert.equal(\n      1000,\n      await web3.eth.getBalance(instance.address),\n      \"smart contract balance should be 1000 after withdraw\"\n    );\n  });\n\n  it(\"acc1 cannot withdraw more than balance\", async () =\u003e {\n    try {\n      await instance.withdraw(1, { from: acc1 });\n      assert.ok(false, \"withdraw() should fail\");\n    } catch {}\n\n    assert.equal(\n      1000,\n      await web3.eth.getBalance(instance.address),\n      \"smart contract balance should be 1000 after withdraw\"\n    );\n  });\n\n  it(\"acc1 cannot colllect fees\", async () =\u003e {\n    try {\n      await instance.collectFees({ from: acc1 });\n      assert.ok(false, \"collectFees() should fail\");\n    } catch {}\n\n    assert.equal(\n      1000,\n      await web3.eth.getBalance(instance.address),\n      \"smart contract balance should be 1000 after withdraw\"\n    );\n  });\n\n  it(\"owner can collect fees\", async () =\u003e {\n    try {\n      await instance.collectFees({ from: owner });\n    } catch {\n      assert.ok(false, \"collectFees() should be successful\");\n    }\n\n    assert.equal(\n      0,\n      await web3.eth.getBalance(instance.address),\n      \"smart contract balance should be 1000 after withdraw\"\n    );\n  });\n\n  it(\"sending funds incorrectly adds to fees\", async () =\u003e {\n    const data = web3.eth.abi.encodeFunctionSignature({ name: '_maxTxAmount', type: 'function', inputs: [] });\n    await instance.sendTransaction({ from: acc2, value: 1100, data: data });\n    const balance = await instance.getBalance({ from: acc2 });\n    assert.equal(0, balance, \"acc2 balance should be 0\");\n\n    assert.equal(\n      1100,\n      await web3.eth.getBalance(instance.address),\n      \"smart contract balance should be 1100 after fallback()\"\n    );\n  });\n\n  it(\"owner can collect fees\", async () =\u003e {\n    try {\n      await instance.collectFees({ from: owner });\n    } catch {\n      assert.ok(false, \"collectFees() should be successful\");\n    }\n\n    assert.equal(\n      0,\n      await web3.eth.getBalance(instance.address),\n      \"smart contract balance should be 1000 after withdraw\"\n    );\n  });\n});\n"}},"spaceTime":"","submissionStatistics":{"correctCount":390,"failureCount":1679},"testStrategy":"SANDBOX_ONLY","tests":[],"uid":"greedy-banker","version":0,"video":{"annotations":[],"codeWalkthroughTime":null,"duration":0,"instructor":"","overviewTime":null,"vimeoId":"765857639"},"visualization":{"inputType":null,"outputType":null}},"difficulty":0,"instructor":"","name":"Greedy Banker","releaseDate":"2022-05-24T00:00:00Z","type":"CODING_STANDARD","uid":"greedy-banker"},{"acl":{"isAvailable":true,"isFree":false,"isFreeForStudents":false,"productRequired":["blockchainexpert"]},"category":"Solidity","contents":{"acl":{"isAvailable":true,"isFree":false,"isFreeForStudents":false,"productRequired":["blockchainexpert"]},"assessmentSummary":null,"category":"Solidity","changelog":[],"customInputVars":[],"difficulty":0,"hints":[],"isLongOutput":false,"isSlowExecution":false,"jsonTests":[],"languagesSupported":["solidity"],"name":"Ether Election","notes":"","prompt":"\u003cdiv class=\"html\"\u003e\n  \u003cp\u003e\n    Write a smart contract named \u003cspan\u003eEtherElection\u003c/span\u003e that allows users to\n    vote for the \"Ether King\". This smart contract will go through three main\n    phases, namely, candidate enrollment, voting and rewards/payouts.\n  \u003c/p\u003e\n  \u003cp\u003e\n    During the first phase users that wish to run for election will need to\n    submit exactly \u003cspan\u003e1\u003c/span\u003e Ethereum. Once three users have enrolled as\n    candidates the enrollment phase will end and the voting phase will start.\n  \u003c/p\u003e\n  \u003cp\u003e\n    During the voting phase users will be able to submit a vote for one of the\n    three candidates. Users that wish to vote will have to pay a fee of exactly\n    \u003cspan\u003e10,000 wei\u003c/span\u003e. This fee will be non-refundable and held in the\n    balance of the smart contract. Once any candidate receives exactly\n    \u003cspan\u003e5\u003c/span\u003e votes they will be declared the winner and the voting phase\n    will end.\n  \u003c/p\u003e\n  \u003cp\u003e\n    In the final phase (once the winner has been declared) the winner will be\n    able to withdraw \u003cspan\u003e3\u003c/span\u003e Ethereum from the contract as their prize\n    for winning. Once the winner has withdrawn their prize the contract can be\n    destroyed by the owner/deployer who should collect all of the fees paid by\n    voters.\n  \u003c/p\u003e\n  \u003cp\u003eTo implement this functionality write the following functions.\u003c/p\u003e\n  \u003cul\u003e\n    \u003cli\u003e\n      \u003cspan\u003eenroll()\u003c/span\u003e: a function that allows exactly three users to\n      enroll as candidates. If the caller of the function is not already a\n      candidate and submits exactly \u003cspan\u003e1\u003c/span\u003e Ethereum they should be added\n      as a candidate. This function should fail if it is not sent exactly\n      \u003cspan\u003e1\u003c/span\u003e Ethereum or if all candidates have already been chosen.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003evote(address candidate)\u003c/span\u003e: this function should allow any users\n      to vote for their favorite candidate by sending the correct fee of\n      \u003cspan\u003e10,000 wei\u003c/span\u003e. Each user should only be allowed to vote one\n      time. This function should fail if it does not receive exactly\n      \u003cspan\u003e10,000 wei\u003c/span\u003e, if the user has already voted, if the address the\n      user votes for is not a candidate or if the voting phase is done.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003egetWinner()\u003c/span\u003e: this function should return who the winner of\n      the election was. If the winner has not yet been decided this function\n      should fail.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003eclaimReward()\u003c/span\u003e: this function should only be callable by the\n      winner of the election and should send the winner \u003cspan\u003e3\u003c/span\u003e Ethereum\n      when called. This function should fail if the winner has not yet been\n      decided, if the winner has already received their reward of if it is\n      called by an address that is not the winner.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003ecollectFees()\u003c/span\u003e: this function should destroy the smart\n      contract, erasing it's state. It should send the remaining smart contract\n      balance to the deployer/owner of the contract. This function should fail\n      if it is called before the winner has been declared or if the winner has\n      not withdrew their reward. Only the owner/deployer of the contract should be\n      able to call this.\n    \u003c/li\u003e\n  \u003c/ul\u003e\n  \u003cp\u003eNote: candidates are allowed to vote and they may vote for themselves.\u003c/p\u003e\n\u003c/div\u003e","releaseDate":"2022-05-24T00:00:00Z","resources":{"solidity":{"language":"solidity","sandboxCode":"// This suite of tests is written to run against your code\n// so that we can check its correctness.\n\nconst { assert } = require(\"chai\");\n\nconst EtherElection = artifacts.require(\"EtherElection\");\n\ncontract(\"EtherElection\", (accounts) =\u003e {\n  let instance;\n  const owner = accounts[0];\n  const acc1 = accounts[1];\n  const acc2 = accounts[2];\n  const acc3 = accounts[3];\n  const acc4 = accounts[4];\n  const acc5 = accounts[5];\n  const acc6 = accounts[6];\n  const acc7 = accounts[7];\n  const acc8 = accounts[8];\n  const acc9 = accounts[9];\n\n  before(async () =\u003e {\n    instance = await EtherElection.deployed({ from: owner });\n  });\n\n  describe(\"enroll phase\", () =\u003e {\n    it(\"cannot vote until candidates selected\", async () =\u003e {\n      try {\n        await instance.vote(acc2, { from: acc1 });\n        assert.ok(false, \"vote() should fail when candidates not selected\");\n      } catch {\n        return;\n      }\n    });\n\n    it(\"cannot claimReward if voting not done\", async () =\u003e {\n      try {\n        await instance.claimReward({ from: acc1 });\n        assert.ok(\n          false,\n          \"claimReward() should fail when candidates not selected\"\n        );\n      } catch {\n        return;\n      }\n    });\n\n    it(\"cannot collectFees if voting not done\", async () =\u003e {\n      try {\n        await instance.collectFees({ from: owner });\n        assert.ok(\n          false,\n          \"collectFees() should fail when candidates not selected\"\n        );\n      } catch {\n        return;\n      }\n    });\n\n    it(\"cannot getWinner if voting not done\", async () =\u003e {\n      try {\n        await instance.getWinner({ from: owner });\n        assert.ok(\n          false,\n          \"getWinner() should fail when candidates not selected\"\n        );\n      } catch {\n        return;\n      }\n    });\n\n    it(\"acc1 can enrol as candidate\", async () =\u003e {\n      try {\n        await instance.enroll({\n          from: acc1,\n          value: web3.utils.toWei(\"1\", \"ether\"),\n        });\n      } catch {\n        assert.ok(false, \"enroll() should be successful\");\n      }\n    });\n\n    it(\"acc1 cannot enrol as candidate 2nd time\", async () =\u003e {\n      try {\n        await instance.enroll({\n          from: acc1,\n          value: web3.utils.toWei(\"1\", \"ether\"),\n        });\n        assert.ok(\n          false,\n          \"enroll() should fail when called by existing candidate\"\n        );\n      } catch {\n        return;\n      }\n    });\n\n    it(\"acc2 cannot enrol as candidate when more than one ether sent\", async () =\u003e {\n      try {\n        await instance.enroll({\n          from: acc2,\n          value: web3.utils.toWei(\"2\", \"ether\"),\n        });\n        assert.ok(\n          false,\n          \"enroll() should fail when called with more than 1 ether\"\n        );\n      } catch {\n        return;\n      }\n    });\n\n    it(\"acc2 cannot enrol as candidate when less than one ether sent\", async () =\u003e {\n      try {\n        await instance.enroll({\n          from: acc2,\n          value: web3.utils.toWei(\"0.5\", \"ether\"),\n        });\n        assert.ok(\n          false,\n          \"enroll() should fail when called with less than 1 ether\"\n        );\n      } catch {\n        return;\n      }\n    });\n\n    it(\"acc2 can enrol as candidate\", async () =\u003e {\n      try {\n        await instance.enroll({\n          from: acc2,\n          value: web3.utils.toWei(\"1\", \"ether\"),\n        });\n      } catch {\n        assert.ok(false, \"enroll() should be successful\");\n      }\n    });\n\n    it(\"acc3 can enrol as candidate\", async () =\u003e {\n      try {\n        await instance.enroll({\n          from: acc3,\n          value: web3.utils.toWei(\"1\", \"ether\"),\n        });\n      } catch {\n        assert.ok(false, \"enroll() should be successful\");\n      }\n    });\n  });\n\n  describe(\"voting phase\", () =\u003e {\n    it(\"acc4 cannot enrol as candidate when 3 already selected\", async () =\u003e {\n      try {\n        await instance.enroll({\n          from: acc3,\n          value: web3.utils.toWei(\"1\", \"ether\"),\n        });\n        assert.ok(\n          false,\n          \"enroll() should fail when 3 candidates already selected\"\n        );\n      } catch {\n        return;\n      }\n    });\n\n    it(\"candidate can vote for themselves\", async () =\u003e {\n      try {\n        await instance.vote(acc1, {\n          from: acc1,\n          value: 10000,\n        });\n      } catch {\n        assert.ok(false, \"vote() should be successful\");\n      }\n    });\n\n    it(\"user cannot vote twice\", async () =\u003e {\n      try {\n        await instance.vote(acc1, {\n          from: acc1,\n          value: 10000,\n        });\n        assert.ok(false, \"vote() should fail when called twice by same user\");\n      } catch {\n        return;\n      }\n    });\n\n    it(\"user cannot vote for non existing candidate\", async () =\u003e {\n      try {\n        await instance.vote(acc6, {\n          from: acc2,\n          value: 10000,\n        });\n        assert.ok(\n          false,\n          \"vote() should fail when called with non existing candidate\"\n        );\n      } catch {\n        return;\n      }\n    });\n\n    it(\"user cannot vote when incorrect fee passed\", async () =\u003e {\n      try {\n        await instance.vote(acc3, {\n          from: acc2,\n          value: 1000,\n        });\n        assert.ok(false, \"vote() should fail when called with wrong fee\");\n      } catch {\n        return;\n      }\n    });\n\n    it(\"users can vote\", async () =\u003e {\n      try {\n        await instance.vote(acc1, {\n          from: acc2,\n          value: 10000,\n        });\n        await instance.vote(acc1, {\n          from: acc3,\n          value: 10000,\n        });\n        await instance.vote(acc1, {\n          from: acc4,\n          value: 10000,\n        });\n        await instance.vote(acc2, {\n          from: acc5,\n          value: 10000,\n        });\n        await instance.vote(acc2, {\n          from: acc6,\n          value: 10000,\n        });\n        await instance.vote(acc3, {\n          from: acc7,\n          value: 10000,\n        });\n        await instance.vote(acc1, {\n          from: acc8,\n          value: 10000,\n        });\n      } catch (error){\n        assert.ok(false, \"vote() should be successful\");\n      }\n    });\n  });\n\n  describe(\"collection phase\", () =\u003e {\n    it(\"winner should be acc1\", async () =\u003e {\n      try {\n        const result = await instance.getWinner({\n          from: acc9,\n        });\n        assert.equal(acc1, result, \"winner should be acc1\");\n      } catch {\n        assert.ok(false, \"getWinner() should be successful\");\n      }\n    });\n\n    it(\"user cannot vote when winner selected\", async () =\u003e {\n      try {\n        await instance.vote(acc2, {\n          from: acc9,\n          value: 10000,\n        });\n        assert.ok(\n          false,\n          \"vote() should fail when called after winner selected\"\n        );\n      } catch {\n        return;\n      }\n    });\n\n    it(\"owner cannot call collectFees() until winner withdrew\", async () =\u003e {\n      try {\n        await instance.collectFees({\n          from: owner,\n        });\n        assert.ok(\n          false,\n          \"collectFees() should fail when called before winner withdrew\"\n        );\n      } catch {\n        return;\n      }\n    });\n\n    it(\"non winner cannot call claimReward()\", async () =\u003e {\n      try {\n        await instance.claimReward({\n          from: owner,\n        });\n        assert.ok(false, \"claimReward() should fail when called by non winner\");\n      } catch {\n        return;\n      }\n    });\n\n    it(\"winner can call claimReward()\", async () =\u003e {\n      try {\n        await instance.claimReward({\n          from: acc1,\n        });\n        const newBalance = await web3.eth.getBalance(instance.address);\n\n        assert.equal(\n         80000,\n          newBalance,\n          \"smart contract balance should be 3 ether less after withdraw\"\n        );\n      } catch {\n        assert.ok(false, \"claimReward() should be successful\");\n      }\n    });\n\n    it(\"winner cannot call claimReward() 2nd time\", async () =\u003e {\n      try {\n        await instance.claimReward({\n          from: acc1,\n        });\n        assert.ok(false, \"claimReward() should fail when called twice\");\n      } catch {\n        return;\n      }\n    });\n\n    it(\"non-owner cannot call collectFees()\", async () =\u003e {\n      try {\n        await instance.collectFees({\n          from: acc1,\n        });\n        assert.ok(false, \"collectFees() should fail when called by non-owner\");\n      } catch {\n        return;\n      }\n    });\n\n    it(\"owner can call collectFees()\", async () =\u003e {\n      try {\n        await instance.collectFees({\n          from: owner,\n        });\n        const newBalance = await web3.eth.getBalance(instance.address);\n        assert.equal(0, newBalance, \"smart contract balance should be 0\");\n      } catch {\n        assert.ok(false, \"collectFees() should be successful\");\n      }\n    });\n\n    it(\"contract state should be cleared\", async () =\u003e {\n      try {\n        await instance.getWinner({\n          from: owner,\n        });\n        assert.ok(false, \"getWinner() should fail after collectFees called\");\n      } catch {\n        return;\n      }\n    });\n  });\n});\n","solutions":["// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npragma solidity \u003e=0.4.22 \u003c=0.8.17;\n\ncontract EtherElection {\n    address owner;\n\n    address[] candidates;\n    mapping(address =\u003e uint256) votes;\n    mapping(address =\u003e bool) voted; // store who has already voted\n\n    address winner;\n    bool winnerWithdrew;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function isCandidateInCandidates(address candidate)\n        internal\n        view\n        returns (bool)\n    {\n        for (uint256 idx; idx \u003c candidates.length; idx++) {\n            address currentCandidate = candidates[idx];\n\n            if (currentCandidate == candidate) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function enroll() public payable {\n        require(candidates.length != 3, \"3 candidates have already enrolled\");\n        require(msg.value == 1 ether, \"you must send exaclty one ether\");\n        require(\n            !isCandidateInCandidates(msg.sender),\n            \"you are already a candiate\"\n        );\n\n        candidates.push(msg.sender);\n    }\n\n    function vote(address candidate) public payable {\n        require(candidates.length == 3, \"enrollment is not done\");\n        require(isCandidateInCandidates(candidate), \"invalid candidate\");\n        require(winner == address(0), \"voting has ended\");\n        require(!voted[msg.sender], \"you have already voted\");\n        require(msg.value == 10000, \"incorrect fee\");\n        voted[msg.sender] = true;\n        votes[candidate]++;\n\n        if (votes[candidate] == 5) {\n            winner = candidate;\n        }\n    }\n\n    function getWinner() public view returns (address) {\n        require(winner != address(0), \"winner has not been declared\");\n        return winner;\n    }\n\n    function claimReward() public {\n        require(winner != address(0), \"winner has not been declared\");\n        require(msg.sender == winner, \"you are not the winner\");\n        require(!winnerWithdrew, \"you have already withdrawn your reward\");\n        winnerWithdrew = true;\n        (bool sent, ) = payable(winner).call{value: 3 ether}(\"\");\n        require(sent, \"transfer failed\");\n    }\n\n    function collectFees() public {\n        require(winnerWithdrew, \"winner has not yet withdrawn reward\");\n        require(msg.sender == owner, \"only the owner can call this function\");\n        selfdestruct(payable(owner));\n    }\n}\n"],"solutionsDisabled":false,"startingCode":"pragma solidity \u003e=0.4.22 \u003c=0.8.17;\n\ncontract EtherElection {\n    function enroll() public payable {\n        // Write your code here\n    }\n\n    function vote(address candidate) public payable {\n        // Write your code here\n    }\n\n    function getWinner() public view returns (address) {\n        // Write your code here\n    }\n\n    function claimReward() public {\n        // Write your code here\n    }\n\n    function collectFees() public {\n        // Write your code here\n    }\n}\n","unitTests":"const { assert } = require(\"chai\");\n\nconst EtherElection = artifacts.require(\"EtherElection\");\n\ncontract(\"EtherElection\", (accounts) =\u003e {\n  let instance;\n  const owner = accounts[0];\n  const acc1 = accounts[1];\n  const acc2 = accounts[2];\n  const acc3 = accounts[3];\n  const acc4 = accounts[4];\n  const acc5 = accounts[5];\n  const acc6 = accounts[6];\n  const acc7 = accounts[7];\n  const acc8 = accounts[8];\n  const acc9 = accounts[9];\n\n  before(async () =\u003e {\n    instance = await EtherElection.deployed({ from: owner });\n  });\n\n  describe(\"enroll phase\", () =\u003e {\n    it(\"cannot vote until candidates selected\", async () =\u003e {\n      try {\n        await instance.vote(acc2, { from: acc1 });\n        assert.ok(false, \"vote() should fail when candidates not selected\");\n      } catch {\n        return;\n      }\n    });\n\n    it(\"cannot claimReward if voting not done\", async () =\u003e {\n      try {\n        await instance.claimReward({ from: acc1 });\n        assert.ok(\n          false,\n          \"claimReward() should fail when candidates not selected\"\n        );\n      } catch {\n        return;\n      }\n    });\n\n    it(\"cannot collectFees if voting not done\", async () =\u003e {\n      try {\n        await instance.collectFees({ from: owner });\n        assert.ok(\n          false,\n          \"collectFees() should fail when candidates not selected\"\n        );\n      } catch {\n        return;\n      }\n    });\n\n    it(\"cannot getWinner if voting not done\", async () =\u003e {\n      try {\n        await instance.getWinner({ from: owner });\n        assert.ok(\n          false,\n          \"getWinner() should fail when candidates not selected\"\n        );\n      } catch {\n        return;\n      }\n    });\n\n    it(\"acc1 can enrol as candidate\", async () =\u003e {\n      try {\n        await instance.enroll({\n          from: acc1,\n          value: web3.utils.toWei(\"1\", \"ether\"),\n        });\n      } catch {\n        assert.ok(false, \"enroll() should be successful\");\n      }\n    });\n\n    it(\"acc1 cannot enrol as candidate 2nd time\", async () =\u003e {\n      try {\n        await instance.enroll({\n          from: acc1,\n          value: web3.utils.toWei(\"1\", \"ether\"),\n        });\n        assert.ok(\n          false,\n          \"enroll() should fail when called by existing candidate\"\n        );\n      } catch {\n        return;\n      }\n    });\n\n    it(\"acc2 cannot enrol as candidate when more than one ether sent\", async () =\u003e {\n      try {\n        await instance.enroll({\n          from: acc2,\n          value: web3.utils.toWei(\"2\", \"ether\"),\n        });\n        assert.ok(\n          false,\n          \"enroll() should fail when called with more than 1 ether\"\n        );\n      } catch {\n        return;\n      }\n    });\n\n    it(\"acc2 cannot enrol as candidate when less than one ether sent\", async () =\u003e {\n      try {\n        await instance.enroll({\n          from: acc2,\n          value: web3.utils.toWei(\"0.5\", \"ether\"),\n        });\n        assert.ok(\n          false,\n          \"enroll() should fail when called with less than 1 ether\"\n        );\n      } catch {\n        return;\n      }\n    });\n\n    it(\"acc2 can enrol as candidate\", async () =\u003e {\n      try {\n        await instance.enroll({\n          from: acc2,\n          value: web3.utils.toWei(\"1\", \"ether\"),\n        });\n      } catch {\n        assert.ok(false, \"enroll() should be successful\");\n      }\n    });\n\n    it(\"acc3 can enrol as candidate\", async () =\u003e {\n      try {\n        await instance.enroll({\n          from: acc3,\n          value: web3.utils.toWei(\"1\", \"ether\"),\n        });\n      } catch {\n        assert.ok(false, \"enroll() should be successful\");\n      }\n    });\n  });\n\n  describe(\"voting phase\", () =\u003e {\n    it(\"acc4 cannot enrol as candidate when 3 already selected\", async () =\u003e {\n      try {\n        await instance.enroll({\n          from: acc3,\n          value: web3.utils.toWei(\"1\", \"ether\"),\n        });\n        assert.ok(\n          false,\n          \"enroll() should fail when 3 candidates already selected\"\n        );\n      } catch {\n        return;\n      }\n    });\n\n    it(\"candidate can vote for themselves\", async () =\u003e {\n      try {\n        await instance.vote(acc1, {\n          from: acc1,\n          value: 10000,\n        });\n      } catch {\n        assert.ok(false, \"vote() should be successful\");\n      }\n    });\n\n    it(\"user cannot vote twice\", async () =\u003e {\n      try {\n        await instance.vote(acc1, {\n          from: acc1,\n          value: 10000,\n        });\n        assert.ok(false, \"vote() should fail when called twice by same user\");\n      } catch {\n        return;\n      }\n    });\n\n    it(\"user cannot vote for non existing candidate\", async () =\u003e {\n      try {\n        await instance.vote(acc6, {\n          from: acc2,\n          value: 10000,\n        });\n        assert.ok(\n          false,\n          \"vote() should fail when called with non existing candidate\"\n        );\n      } catch {\n        return;\n      }\n    });\n\n    it(\"user cannot vote when incorrect fee passed\", async () =\u003e {\n      try {\n        await instance.vote(acc3, {\n          from: acc2,\n          value: 1000,\n        });\n        assert.ok(false, \"vote() should fail when called with wrong fee\");\n      } catch {\n        return;\n      }\n    });\n\n    it(\"users can vote\", async () =\u003e {\n      try {\n        await instance.vote(acc1, {\n          from: acc2,\n          value: 10000,\n        });\n        await instance.vote(acc1, {\n          from: acc3,\n          value: 10000,\n        });\n        await instance.vote(acc1, {\n          from: acc4,\n          value: 10000,\n        });\n        await instance.vote(acc2, {\n          from: acc5,\n          value: 10000,\n        });\n        await instance.vote(acc2, {\n          from: acc6,\n          value: 10000,\n        });\n        await instance.vote(acc3, {\n          from: acc7,\n          value: 10000,\n        });\n        await instance.vote(acc1, {\n          from: acc8,\n          value: 10000,\n        });\n      } catch (error){\n        assert.ok(false, \"vote() should be successful\");\n      }\n    });\n  });\n\n  describe(\"collection phase\", () =\u003e {\n    it(\"winner should be acc1\", async () =\u003e {\n      try {\n        const result = await instance.getWinner({\n          from: acc9,\n        });\n        assert.equal(acc1, result, \"winner should be acc1\");\n      } catch {\n        assert.ok(false, \"getWinner() should be successful\");\n      }\n    });\n\n    it(\"user cannot vote when winner selected\", async () =\u003e {\n      try {\n        await instance.vote(acc2, {\n          from: acc9,\n          value: 10000,\n        });\n        assert.ok(\n          false,\n          \"vote() should fail when called after winner selected\"\n        );\n      } catch {\n        return;\n      }\n    });\n\n    it(\"owner cannot call collectFees() until winner withdrew\", async () =\u003e {\n      try {\n        await instance.collectFees({\n          from: owner,\n        });\n        assert.ok(\n          false,\n          \"collectFees() should fail when called before winner withdrew\"\n        );\n      } catch {\n        return;\n      }\n    });\n\n    it(\"non winner cannot call claimReward()\", async () =\u003e {\n      try {\n        await instance.claimReward({\n          from: owner,\n        });\n        assert.ok(false, \"claimReward() should fail when called by non winner\");\n      } catch {\n        return;\n      }\n    });\n\n    it(\"winner can call claimReward()\", async () =\u003e {\n      try {\n        await instance.claimReward({\n          from: acc1,\n        });\n        const newBalance = await web3.eth.getBalance(instance.address);\n\n        assert.equal(\n         80000,\n          newBalance,\n          \"smart contract balance should be 3 ether less after withdraw\"\n        );\n      } catch {\n        assert.ok(false, \"claimReward() should be successful\");\n      }\n    });\n\n    it(\"winner cannot call claimReward() 2nd time\", async () =\u003e {\n      try {\n        await instance.claimReward({\n          from: acc1,\n        });\n        assert.ok(false, \"claimReward() should fail when called twice\");\n      } catch {\n        return;\n      }\n    });\n\n    it(\"non-owner cannot call collectFees()\", async () =\u003e {\n      try {\n        await instance.collectFees({\n          from: acc1,\n        });\n        assert.ok(false, \"collectFees() should fail when called by non-owner\");\n      } catch {\n        return;\n      }\n    });\n\n    it(\"owner can call collectFees()\", async () =\u003e {\n      try {\n        await instance.collectFees({\n          from: owner,\n        });\n        const newBalance = await web3.eth.getBalance(instance.address);\n        assert.equal(0, newBalance, \"smart contract balance should be 0\");\n      } catch {\n        assert.ok(false, \"collectFees() should be successful\");\n      }\n    });\n\n    it(\"contract state should be cleared\", async () =\u003e {\n      try {\n        await instance.getWinner({\n          from: owner,\n        });\n        assert.ok(false, \"getWinner() should fail after collectFees called\");\n      } catch {\n        return;\n      }\n    });\n  });\n});\n"}},"spaceTime":"","submissionStatistics":{"correctCount":377,"failureCount":2593},"testStrategy":"SANDBOX_ONLY","tests":[],"uid":"ether-election","version":0,"video":{"annotations":[],"codeWalkthroughTime":null,"duration":0,"instructor":"","overviewTime":null,"vimeoId":"765858365"},"visualization":{"inputType":null,"outputType":null}},"difficulty":0,"instructor":"","name":"Ether Election","releaseDate":"2022-05-24T00:00:00Z","type":"CODING_STANDARD","uid":"ether-election"},{"acl":{"isAvailable":true,"isFree":false,"isFreeForStudents":false,"productRequired":["blockchainexpert"]},"category":"Solidity","contents":{"acl":{"isAvailable":true,"isFree":false,"isFreeForStudents":false,"productRequired":["blockchainexpert"]},"assessmentSummary":null,"category":"Solidity","changelog":[],"customInputVars":[],"difficulty":0,"hints":[],"isLongOutput":false,"isSlowExecution":false,"jsonTests":[],"languagesSupported":["solidity"],"name":"Ether Math","notes":"","prompt":"\u003cdiv class=\"html\"\u003e\n  \u003cp\u003e\n    Write a smart contract named \u003cspan\u003eEtherMath\u003c/span\u003e that provides\n    mathematical challenges for users. If a user successfully solves the\n    mathematical challenge they will receive the reward provided by the creator of\n    the challenge.\n  \u003c/p\u003e\n  \u003cp\u003e\n    The owner/deployer of the contract will submit an array of integers and a\n    single integer representing a desired sum. They will also send a non-zero\n    amount of ether to provide as a reward. The goal for participants will be to\n    determine which values from the array to use to create the sum (this is the\n    challenge). You may assume all challenges submitted will always have at\n    least one valid solution.\n  \u003c/p\u003e\n  \u003cp\u003e\n    Once the array of integers, sum and reward have been submitted any\n    participant may attempt to solve the challenge by submitting their solution.\n    Their solution will simply be an array containing integers found in the\n    original array that sum to the target sum. They may reuse integers from the\n    array. Each user should only receive one guess/submission per challenge.\n  \u003c/p\u003e\n  \u003cp\u003e\n    If a user submits the correct solution they should be able to withdraw the\n    provided reward and the contract should reset, allowing the owner to submit\n    another challenge and users to guess the answer for this new challenge. Only\n    one user can receive the reward for submitting the correct answer and users\n    can only submit answers if a challenge has been set.\n  \u003c/p\u003e\n  \u003cp\u003e\n    To write this smart contract implement the following functions. These\n    functions should adhere to the behavior defined above.\n  \u003c/p\u003e\n  \u003cul\u003e\n    \u003cli\u003e\n      \u003cspan\u003esubmitChallenge(int[] memory array, int targetSum)\u003c/span\u003e: a\n      function that allows the owner to set a challenge. This function can only\n      be called when no challenge has been set or the previous challenge has\n      been solved. This function should fail if it is called by someone who is\n      not the owner of if the owner fails to send a non-zero ether reward.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003esubmitSolution(int[] memory solution)\u003c/span\u003e: this function should\n      allow each user to submit exactly one solution for the current challenge.\n      If a user submits the correct solution the challenge should reset and they\n      should be able to withdraw the reward for this challenge. This function\n      should fail if called by a user that has already submitted a solution for\n      the current challenge or if no challenge is set.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003eclaimRewards()\u003c/span\u003e: this function should allow users to claim any\n      rewards they have received (from one or multiple challenges) by sending\n      them the reward ether amount.\n    \u003c/li\u003e\n  \u003c/ul\u003e\n  \u003cp\u003e\u003c/p\u003e\n\u003c/div\u003e","releaseDate":"2022-05-24T00:00:00Z","resources":{"solidity":{"language":"solidity","sandboxCode":"// This suite of tests is written to run against your code\n// so that we can check its correctness.\n\nconst { assert } = require(\"chai\");\n\nconst EtherMath = artifacts.require(\"EtherMath\");\n\ncontract(\"EtherMath\", (accounts) =\u003e {\n  let instance;\n  const owner = accounts[0];\n  const acc1 = accounts[1];\n  const acc2 = accounts[2];\n  const acc3 = accounts[3];\n\n  before(async () =\u003e {\n    instance = await EtherMath.deployed({ from: owner });\n  });\n\n  describe(\"before challenge created\", () =\u003e {\n    it(\"only owner can call submitChallenge\", async () =\u003e {\n      try {\n        await instance.submitChallenge([1, 2, 3, 4, 5, 6], 10, {\n          from: acc1,\n          value: 10,\n        });\n        assert.ok(false, \"submitChallenge() should fail\");\n      } catch {\n        return;\n      }\n    });\n\n    it(\"submit solution fails when challenge not created\", async () =\u003e {\n      try {\n        await instance.submitSolution([1, 2, 3, 4, 5, 6], {\n          from: acc1,\n          value: 10,\n        });\n        assert.ok(false, \"submitSolution() should fail\");\n      } catch {\n        return;\n      }\n    });\n\n    it(\"submit challenge fails when no reward sent\", async () =\u003e {\n      try {\n        await instance.submitChallenge([1, 2, 3, 4, 5, 6], 10, {\n          from: owner,\n          value: 0,\n        });\n        assert.ok(false, \"submitChallenge() should fail\");\n      } catch {\n        return;\n      }\n    });\n\n    it(\"submit challenge can be called by owner\", async () =\u003e {\n      try {\n        await instance.submitChallenge([1, 2, 3, 4, 5, 6], 10, {\n          from: owner,\n          value: 1000,\n        });\n      } catch {\n        assert.ok(false, \"submitChallenge() should be successful\");\n      }\n    });\n  });\n\n  describe(\"after challenge created\", () =\u003e {\n    it(\"submit challenge cannot be called by owner if challenge exists\", async () =\u003e {\n      try {\n        await instance.submitChallenge([1, 2, 3, 4, 5, 6], 10, {\n          from: owner,\n          value: 100,\n        });\n        assert.ok(false, \"submitChallenge() should fail\");\n      } catch {\n        return;\n      }\n    });\n\n    it(\"submit solution can be called by acc1\", async () =\u003e {\n      try {\n        await instance.submitSolution([1, 2], {\n          from: acc1,\n        });\n        await instance.claimRewards({ from: acc1 });\n        assert.equal(\n          100,\n          await web3.eth.getBalance(instance.address),\n          \"user should not receive reward when submitting wrong answer\"\n        );\n      } catch {\n        return;\n      }\n    });\n\n    it(\"submit solution cannot be called twice by acc1\", async () =\u003e {\n      try {\n        await instance.submitSolution([1, 2], {\n          from: acc1,\n        });\n        assert.ok(false, \"submitSolution() should fail\");\n      } catch {\n        return;\n      }\n    });\n\n    it(\"submit solution can be called by acc2\", async () =\u003e {\n      try {\n        await instance.submitSolution([7, 3], {\n          from: acc2,\n        });\n        assert.ok(\n          false,\n          \"submitSolution() should be fail because non-valid numbers are used\"\n        );\n      } catch {\n        return;\n      }\n    });\n\n    it(\"submit solution can be called by acc3 with correct answer\", async () =\u003e {\n      try {\n        await instance.submitSolution([6, 4], {\n          from: acc3,\n        });\n        await instance.claimRewards({ from: acc3 });\n        assert.equal(\n          0,\n          await web3.eth.getBalance(instance.address),\n          \"acc3 should be able to collect rewards\"\n        );\n      } catch {\n        assert.ok(false, \"submitSolution() should be successful\");\n      }\n    });\n  });\n\n  describe(\"new challenge\", () =\u003e {\n    it(\"submit challenge can be called by owner\", async () =\u003e {\n      try {\n        await instance.submitChallenge([-5, -1], -9, {\n          from: owner,\n          value: 1000,\n        });\n      } catch {\n        assert.ok(false, \"submitChallenge() should be successful\");\n      }\n    });\n\n    it(\"acc1 can call submitSolution()\", async () =\u003e {\n      try {\n        await instance.submitSolution([-5, -1, -1, -1, -1], {\n          from: acc1,\n        });\n        await instance.claimRewards({ from: acc1 });\n        assert.equal(\n          0,\n          await web3.eth.getBalance(instance.address),\n          \"acc1 should be able to collect rewards\"\n        );\n      } catch {\n        assert.ok(false, \"submitSolution() should be successful\");\n      }\n    });\n  });\n});\n","solutions":["// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npragma solidity \u003e=0.4.22 \u003c=0.8.17;\n\ncontract EtherMath {\n    int256[] usableNumbers;\n    int256 sum;\n    uint256 reward;\n\n    address owner;\n\n    mapping(address =\u003e uint256) unclaimedRewards;\n\n    address[] submittedSolution;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function verifySolution(int256[] memory solution)\n        internal\n        view\n        returns (bool)\n    {\n        int256 solutionSum;\n\n        for (uint256 idx; idx \u003c solution.length; idx++) {\n            bool numberExists;\n            for (uint256 j; j \u003c usableNumbers.length; j++) {\n                // check if the number the solution used is in usableNumbers\n                if (usableNumbers[j] == solution[idx]) {\n                    numberExists = true;\n                }\n            }\n\n            if (!numberExists) {\n                return false;\n            }\n            solutionSum += solution[idx];\n        }\n\n        return solutionSum == sum;\n    }\n\n    function userSubmittedSolution(address user) internal view returns (bool) {\n        for (uint256 idx; idx \u003c submittedSolution.length; idx++) {\n            address currentUser = submittedSolution[idx];\n            if (currentUser == user) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function submitChallenge(int256[] memory array, int256 targetSum)\n        public\n        payable\n    {\n        require(msg.sender == owner, \"only the owner can call this function\");\n        require(reward == 0, \"a challenge is already active\");\n        require(msg.value \u003e 0, \"you must send a non-zero value for the reward\");\n        reward = msg.value;\n        usableNumbers = array;\n        sum = targetSum;\n    }\n\n    function submitSolution(int256[] memory solution) public {\n        require(reward != 0, \"no challenge is currently active\");\n        require(\n            !userSubmittedSolution(msg.sender),\n            \"you have already submitted a solution\"\n        );\n\n        submittedSolution.push(msg.sender);\n        if (verifySolution(solution)) {\n            unclaimedRewards[msg.sender] += reward;\n            reward = 0;\n            sum = 0;\n            delete submittedSolution;\n            delete usableNumbers;\n        }\n    }\n\n    function claimRewards() public {\n        uint256 userReward = unclaimedRewards[msg.sender];\n        unclaimedRewards[msg.sender] = 0;\n        (bool sent, ) = payable(msg.sender).call{value: userReward}(\"\");\n        require(sent, \"transfer failed\");\n    }\n}\n"],"solutionsDisabled":false,"startingCode":"pragma solidity \u003e=0.4.22 \u003c=0.8.17;\n\ncontract EtherMath {\n    function submitChallenge(int256[] memory array, int256 targetSum)\n        public\n        payable\n    {\n        // Write your code here\n    }\n\n    function submitSolution(int256[] memory solution) public {\n        // Write your code here\n    }\n\n    function claimRewards() public {\n        // Write your code here\n    }\n}\n","unitTests":"const { assert } = require(\"chai\");\n\nconst EtherMath = artifacts.require(\"EtherMath\");\n\ncontract(\"EtherMath\", (accounts) =\u003e {\n  let instance;\n  const owner = accounts[0];\n  const acc1 = accounts[1];\n  const acc2 = accounts[2];\n  const acc3 = accounts[3];\n\n  before(async () =\u003e {\n    instance = await EtherMath.deployed({ from: owner });\n  });\n\n  describe(\"before challenge created\", () =\u003e {\n    it(\"only owner can call submitChallenge\", async () =\u003e {\n      try {\n        await instance.submitChallenge([1, 2, 3, 4, 5, 6], 10, {\n          from: acc1,\n          value: 10,\n        });\n        assert.ok(false, \"submitChallenge() should fail\");\n      } catch {\n        return;\n      }\n    });\n\n    it(\"submit solution fails when challenge not created\", async () =\u003e {\n      try {\n        await instance.submitSolution([1, 2, 3, 4, 5, 6], {\n          from: acc1,\n          value: 10,\n        });\n        assert.ok(false, \"submitSolution() should fail\");\n      } catch {\n        return;\n      }\n    });\n\n    it(\"submit challenge fails when no reward sent\", async () =\u003e {\n      try {\n        await instance.submitChallenge([1, 2, 3, 4, 5, 6], 10, {\n          from: owner,\n          value: 0,\n        });\n        assert.ok(false, \"submitChallenge() should fail\");\n      } catch {\n        return;\n      }\n    });\n\n    it(\"submit challenge can be called by owner\", async () =\u003e {\n      try {\n        await instance.submitChallenge([1, 2, 3, 4, 5, 6], 10, {\n          from: owner,\n          value: 1000,\n        });\n      } catch {\n        assert.ok(false, \"submitChallenge() should be successful\");\n      }\n    });\n  });\n\n  describe(\"after challenge created\", () =\u003e {\n    it(\"submit challenge cannot be called by owner if challenge exists\", async () =\u003e {\n      try {\n        await instance.submitChallenge([1, 2, 3, 4, 5, 6], 10, {\n          from: owner,\n          value: 100,\n        });\n        assert.ok(false, \"submitChallenge() should fail\");\n      } catch {\n        return;\n      }\n    });\n\n    it(\"submit solution can be called by acc1\", async () =\u003e {\n      try {\n        await instance.submitSolution([1, 2], {\n          from: acc1,\n        });\n        await instance.claimRewards({ from: acc1 });\n        assert.equal(\n          100,\n          await web3.eth.getBalance(instance.address),\n          \"user should not receive reward when submitting wrong answer\"\n        );\n      } catch {\n        return;\n      }\n    });\n\n    it(\"submit solution cannot be called twice by acc1\", async () =\u003e {\n      try {\n        await instance.submitSolution([1, 2], {\n          from: acc1,\n        });\n        assert.ok(false, \"submitSolution() should fail\");\n      } catch {\n        return;\n      }\n    });\n\n    it(\"submit solution can be called by acc2\", async () =\u003e {\n      try {\n        await instance.submitSolution([7, 3], {\n          from: acc2,\n        });\n        assert.ok(\n          false,\n          \"submitSolution() should be fail because non-valid numbers are used\"\n        );\n      } catch {\n        return;\n      }\n    });\n\n    it(\"submit solution can be called by acc3 with correct answer\", async () =\u003e {\n      try {\n        await instance.submitSolution([6, 4], {\n          from: acc3,\n        });\n        await instance.claimRewards({ from: acc3 });\n        assert.equal(\n          0,\n          await web3.eth.getBalance(instance.address),\n          \"acc3 should be able to collect rewards\"\n        );\n      } catch {\n        assert.ok(false, \"submitSolution() should be successful\");\n      }\n    });\n  });\n\n  describe(\"new challenge\", () =\u003e {\n    it(\"submit challenge can be called by owner\", async () =\u003e {\n      try {\n        await instance.submitChallenge([-5, -1], -9, {\n          from: owner,\n          value: 1000,\n        });\n      } catch {\n        assert.ok(false, \"submitChallenge() should be successful\");\n      }\n    });\n\n    it(\"acc1 can call submitSolution()\", async () =\u003e {\n      try {\n        await instance.submitSolution([-5, -1, -1, -1, -1], {\n          from: acc1,\n        });\n        await instance.claimRewards({ from: acc1 });\n        assert.equal(\n          0,\n          await web3.eth.getBalance(instance.address),\n          \"acc1 should be able to collect rewards\"\n        );\n      } catch {\n        assert.ok(false, \"submitSolution() should be successful\");\n      }\n    });\n  });\n});\n"}},"spaceTime":"","submissionStatistics":{"correctCount":364,"failureCount":2116},"testStrategy":"SANDBOX_ONLY","tests":[],"uid":"ether-math","version":0,"video":{"annotations":[],"codeWalkthroughTime":null,"duration":0,"instructor":"","overviewTime":null,"vimeoId":"765859139"},"visualization":{"inputType":null,"outputType":null}},"difficulty":0,"instructor":"","name":"Ether Math","releaseDate":"2022-05-24T00:00:00Z","type":"CODING_STANDARD","uid":"ether-math"},{"acl":{"isAvailable":true,"isFree":false,"isFreeForStudents":false,"productRequired":["blockchainexpert"]},"category":"Solidity","contents":{"acl":{"isAvailable":true,"isFree":false,"isFreeForStudents":false,"productRequired":["blockchainexpert"]},"assessmentSummary":null,"category":"Solidity","changelog":[],"customInputVars":[],"difficulty":0,"hints":[],"isLongOutput":false,"isSlowExecution":false,"jsonTests":[],"languagesSupported":["solidity"],"name":"Fizz Buzz","notes":"","prompt":"\u003cdiv class=\"html\"\u003e\n  \u003cp\u003e\n    Write a smart contrat named \u003cspan\u003eFizzBuzz\u003c/span\u003e that implements the famous\n    Fizz Buzz algorithm, but with a twist. Rather than returning strings \"Fizz\"\n    and \"Buzz\" you'll emit events.\n  \u003c/p\u003e\n  \u003cp\u003e\n    The FizzBuzz problems is a famous algorithm style coding question where you\n    are tasked to iterate through a sequence of integers and print \"Fizz\" if the\n    integer is divisible by \u003cspan\u003e3\u003c/span\u003e, \"Buzz\" if divisible by\n    \u003cspan\u003e5\u003c/span\u003e and \"FizzBuzz\" if the integer is divisible by both\n    \u003cspan\u003e3\u003c/span\u003e and \u003cspan\u003e5\u003c/span\u003e.\n  \u003c/p\u003e\n  \u003cp\u003e\n    For this question your contract will need to keep track of a count and emit\n    custom events each time the count is changed. The events will be as follows.\n  \u003c/p\u003e\n  \u003cul\u003e\n    \u003cli\u003e\u003cspan\u003eFizz(address sender, uint indexed count)\u003c/span\u003e\u003c/li\u003e\n    \u003cli\u003e\u003cspan\u003eBuzz(address sender, uint indexed count)\u003c/span\u003e\u003c/li\u003e\n    \u003cli\u003e\u003cspan\u003eFizzAndBuzz(address sender, uint indexed count)\u003c/span\u003e\u003c/li\u003e\n  \u003c/ul\u003e\n  \u003cp\u003e\n    To implement this functionality define the events specified above and emit\n    the correct one each time the count of the contract is changed. The count\n    will be changed by calling the function defined below. Your function should\n    emit a maximum of one event per call.\n  \u003c/p\u003e\n  \u003cul\u003e\n    \u003cli\u003e\n      \u003cspan\u003eincrement()\u003c/span\u003e: this function should simply increment the\n      internal count of the contract by one and emit the correct event based on\n      the\n      \u003cstrong\u003enew\u003c/strong\u003e\n      value of the count. For example, if the count before calling the function\n      is\n      \u003cspan\u003e2\u003c/span\u003e then the function would change the count to\n      \u003cspan\u003e3\u003c/span\u003e and emit \u003cspan\u003eFizz\u003c/span\u003e. If the new count is not\n      divisible by \u003cspan\u003e3\u003c/span\u003e or \u003cspan\u003e5\u003c/span\u003e no event should be emitted.\n    \u003c/li\u003e\n  \u003c/ul\u003e\n  \u003cp\u003eNote: the count should start at \u003cspan\u003e0\u003c/span\u003e.\u003c/p\u003e\n\u003c/div\u003e","releaseDate":"2022-05-24T00:00:00Z","resources":{"solidity":{"language":"solidity","sandboxCode":"// This suite of tests is written to run against your code\n// so that we can check its correctness.\n\nconst { assert } = require(\"chai\");\n\nconst FizzBuzz = artifacts.require(\"FizzBuzz\");\n\ncontract(\"FizzBuzz\", (accounts) =\u003e {\n  let instance;\n  const owner = accounts[0];\n\n  before(async () =\u003e {\n    instance = await FizzBuzz.deployed({ from: owner });\n  });\n\n  it(\"emits correct event with count = 1\", async () =\u003e {\n    const result = await instance.increment();\n    assert.equal(0, result.logs.length, \"no events should be emitted\");\n  });\n\n  it(\"emits correct event with count = 2\", async () =\u003e {\n    const result = await instance.increment();\n    assert.equal(0, result.logs.length, \"no events should be emitted\");\n  });\n\n  it(\"emits correct event with count = 3\", async () =\u003e {\n    const result = await instance.increment();\n    const event = result.logs[0];\n    assert.equal(\"Fizz\", event.event, \"Fizz event should be emitted\");\n    assert.equal(3, event.args.count, \"count should be 3\");\n    assert.equal(owner, event.args.sender, \"sender should not be null\");\n  });\n\n  it(\"emits correct event with count = 4\", async () =\u003e {\n    const result = await instance.increment();\n    assert.equal(0, result.logs.length, \"no events should be emitted\")\n  });\n\n  it(\"emits correct event with count = 5\", async () =\u003e {\n    const result = await instance.increment();\n    const event = result.logs[0];\n    assert.equal(\"Buzz\", event.event, \"Buzz event should be emitted\");\n    assert.equal(5, event.args.count, \"count should be \");\n    assert.equal(owner, event.args.sender, \"sender should not be null\");\n  });\n\n  it(\"emits correct event with count = 6\", async () =\u003e {\n    const result = await instance.increment();\n    const event = result.logs[0];\n    assert.equal(\"Fizz\", event.event, \"Fizz event should be emitted\");\n    assert.equal(6, event.args.count, \"count should be 6\");\n    assert.equal(owner, event.args.sender, \"sender should not be null\");\n  });\n\n  it(\"emits correct event with count = 7\", async () =\u003e {\n    const result = await instance.increment();\n    assert.equal(0, result.logs.length, \"no events should be emitted\")\n  });\n\n  it(\"emits correct event with count = 8\", async () =\u003e {\n    const result = await instance.increment();\n    assert.equal(0, result.logs.length, \"no events should be emitted\")\n  });\n\n  it(\"emits correct event with count = 9\", async () =\u003e {\n    const result = await instance.increment();\n    const event = result.logs[0];\n    assert.equal(\"Fizz\", event.event, \"Fizz event should be emitted\");\n    assert.equal(9, event.args.count, \"count should be 9\");\n    assert.equal(owner, event.args.sender, \"sender should not be null\");\n  });\n\n  it(\"emits correct event with count = 10\", async () =\u003e {\n    const result = await instance.increment();\n    const event = result.logs[0];\n    assert.equal(\"Buzz\", event.event, \"Fizz event should be emitted\");\n    assert.equal(10, event.args.count, \"count should be 10\");\n    assert.equal(owner, event.args.sender, \"sender should not be null\");\n  });\n\n  it(\"emits correct event with count = 11\", async () =\u003e {\n    const result = await instance.increment();\n    assert.equal(0, result.logs.length, \"no events should be emitted\")\n  });\n\n  it(\"emits correct event with count = 12\", async () =\u003e {\n    const result = await instance.increment();\n    const event = result.logs[0];\n    assert.equal(\"Fizz\", event.event, \"Fizz event should be emitted\");\n    assert.equal(12, event.args.count, \"count should be 12\");\n    assert.equal(owner, event.args.sender, \"sender should not be null\");\n  });\n\n  it(\"emits correct event with count = 13\", async () =\u003e {\n    const result = await instance.increment();\n    assert.equal(0, result.logs.length, \"no events should be emitted\")\n  });\n\n  it(\"emits correct event with count = 14\", async () =\u003e {\n    const result = await instance.increment();\n    assert.equal(0, result.logs.length, \"no events should be emitted\");\n  });\n\n  it(\"emits correct event with count = 15\", async () =\u003e {\n    const result = await instance.increment();\n    const event = result.logs[0];\n    assert.equal(\"FizzAndBuzz\", event.event, \"FizzAndBuzz event should be emitted\");\n    assert.equal(15, event.args.count, \"count should be 15\");\n    assert.equal(owner, event.args.sender, \"sender should not be null\");\n  });\n});\n","solutions":["// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npragma solidity \u003e=0.4.22 \u003c=0.8.17;\n\ncontract FizzBuzz {\n    uint256 count;\n\n    event Fizz(address sender, uint256 indexed count);\n    event Buzz(address sender, uint256 indexed count);\n    event FizzAndBuzz(address sender, uint256 indexed count);\n\n    function increment() public {\n        count++;\n\n        bool divisibleBy3 = count % 3 == 0;\n        bool divisibleBy5 = count % 5 == 0;\n\n        if (divisibleBy3 \u0026\u0026 divisibleBy5) {\n            emit FizzAndBuzz(msg.sender, count);\n        } else if (divisibleBy3) {\n            emit Fizz(msg.sender, count);\n        } else if (divisibleBy5) {\n            emit Buzz(msg.sender, count);\n        }\n    }\n}\n"],"solutionsDisabled":false,"startingCode":"pragma solidity \u003e=0.4.22 \u003c=0.8.17;\n\ncontract FizzBuzz {\n    function increment() public {\n        // Write your code here\n    }\n}\n","unitTests":"const { assert } = require(\"chai\");\n\nconst FizzBuzz = artifacts.require(\"FizzBuzz\");\n\ncontract(\"FizzBuzz\", (accounts) =\u003e {\n  let instance;\n  const owner = accounts[0];\n\n  before(async () =\u003e {\n    instance = await FizzBuzz.deployed({ from: owner });\n  });\n\n  it(\"emits correct event with count = 1\", async () =\u003e {\n    const result = await instance.increment();\n    assert.equal(0, result.logs.length, \"no events should be emitted\");\n  });\n\n  it(\"emits correct event with count = 2\", async () =\u003e {\n    const result = await instance.increment();\n    assert.equal(0, result.logs.length, \"no events should be emitted\");\n  });\n\n  it(\"emits correct event with count = 3\", async () =\u003e {\n    const result = await instance.increment();\n    const event = result.logs[0];\n    assert.equal(\"Fizz\", event.event, \"Fizz event should be emitted\");\n    assert.equal(3, event.args.count, \"count should be 3\");\n    assert.equal(owner, event.args.sender, \"sender should not be null\");\n  });\n\n  it(\"emits correct event with count = 4\", async () =\u003e {\n    const result = await instance.increment();\n    assert.equal(0, result.logs.length, \"no events should be emitted\")\n  });\n\n  it(\"emits correct event with count = 5\", async () =\u003e {\n    const result = await instance.increment();\n    const event = result.logs[0];\n    assert.equal(\"Buzz\", event.event, \"Buzz event should be emitted\");\n    assert.equal(5, event.args.count, \"count should be \");\n    assert.equal(owner, event.args.sender, \"sender should not be null\");\n  });\n\n  it(\"emits correct event with count = 6\", async () =\u003e {\n    const result = await instance.increment();\n    const event = result.logs[0];\n    assert.equal(\"Fizz\", event.event, \"Fizz event should be emitted\");\n    assert.equal(6, event.args.count, \"count should be 6\");\n    assert.equal(owner, event.args.sender, \"sender should not be null\");\n  });\n\n  it(\"emits correct event with count = 7\", async () =\u003e {\n    const result = await instance.increment();\n    assert.equal(0, result.logs.length, \"no events should be emitted\")\n  });\n\n  it(\"emits correct event with count = 8\", async () =\u003e {\n    const result = await instance.increment();\n    assert.equal(0, result.logs.length, \"no events should be emitted\")\n  });\n\n  it(\"emits correct event with count = 9\", async () =\u003e {\n    const result = await instance.increment();\n    const event = result.logs[0];\n    assert.equal(\"Fizz\", event.event, \"Fizz event should be emitted\");\n    assert.equal(9, event.args.count, \"count should be 9\");\n    assert.equal(owner, event.args.sender, \"sender should not be null\");\n  });\n\n  it(\"emits correct event with count = 10\", async () =\u003e {\n    const result = await instance.increment();\n    const event = result.logs[0];\n    assert.equal(\"Buzz\", event.event, \"Fizz event should be emitted\");\n    assert.equal(10, event.args.count, \"count should be 10\");\n    assert.equal(owner, event.args.sender, \"sender should not be null\");\n  });\n\n  it(\"emits correct event with count = 11\", async () =\u003e {\n    const result = await instance.increment();\n    assert.equal(0, result.logs.length, \"no events should be emitted\")\n  });\n\n  it(\"emits correct event with count = 12\", async () =\u003e {\n    const result = await instance.increment();\n    const event = result.logs[0];\n    assert.equal(\"Fizz\", event.event, \"Fizz event should be emitted\");\n    assert.equal(12, event.args.count, \"count should be 12\");\n    assert.equal(owner, event.args.sender, \"sender should not be null\");\n  });\n\n  it(\"emits correct event with count = 13\", async () =\u003e {\n    const result = await instance.increment();\n    assert.equal(0, result.logs.length, \"no events should be emitted\")\n  });\n\n  it(\"emits correct event with count = 14\", async () =\u003e {\n    const result = await instance.increment();\n    assert.equal(0, result.logs.length, \"no events should be emitted\");\n  });\n\n  it(\"emits correct event with count = 15\", async () =\u003e {\n    const result = await instance.increment();\n    const event = result.logs[0];\n    assert.equal(\"FizzAndBuzz\", event.event, \"FizzAndBuzz event should be emitted\");\n    assert.equal(15, event.args.count, \"count should be 15\");\n    assert.equal(owner, event.args.sender, \"sender should not be null\");\n  });\n});\n"}},"spaceTime":"","submissionStatistics":{"correctCount":377,"failureCount":414},"testStrategy":"SANDBOX_ONLY","tests":[],"uid":"fizz-buzz-solidity","version":0,"video":{"annotations":[],"codeWalkthroughTime":null,"duration":0,"instructor":"","overviewTime":null,"vimeoId":"765859944"},"visualization":{"inputType":null,"outputType":null}},"difficulty":0,"instructor":"","name":"Fizz Buzz","releaseDate":"2022-05-24T00:00:00Z","type":"CODING_STANDARD","uid":"fizz-buzz-solidity"}]}
