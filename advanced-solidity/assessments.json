{"uid":"advanced-solidity-assessment","name":"Advanced Solidity Assessment","questions":[{"acl":{"isAvailable":true,"isFree":false,"isFreeForStudents":false,"productRequired":["blockchainexpert"]},"category":"Solidity","contents":{"acl":{"isAvailable":true,"isFree":false,"isFreeForStudents":false,"productRequired":["blockchainexpert"]},"assessmentSummary":null,"category":"Solidity","changelog":[],"customInputVars":[],"difficulty":0,"hints":[],"isLongOutput":false,"isSlowExecution":false,"jsonTests":[],"languagesSupported":["solidity"],"name":"Friend Requests","notes":"","prompt":"\u003cdiv class=\"html\"\u003e\n  \u003cp\u003e\n    Write a smart contract named \u003cspan\u003eFriends\u003c/span\u003e that allows users to send\n    and accept friend requests. The following are rules this smart contract\n    should adhere to.\n  \u003c/p\u003e\n  \u003cul\u003e\n    \u003cli\u003e\n      A user cannot cannot send more than one friend request to the same\n      address.\n    \u003c/li\u003e\n    \u003cli\u003e\n      A user cannot send a friend request to a user that has sent them a friend\n      request.\n    \u003c/li\u003e\n    \u003cli\u003e\n      A user cannot send a friend request to a user they are already friends\n      with.\n    \u003c/li\u003e\n    \u003cli\u003e\n      A user cannot accept a friend request that doesn't exist or that they have\n      already accepted.\n    \u003c/li\u003e\n    \u003cli\u003eA user cannot send a friend request to themselves.\u003c/li\u003e\n  \u003c/ul\u003e\n  \u003cp\u003e\n    Use advanced solidity features like modifiers and structs when implementing\n    the functions defined below.\n  \u003c/p\u003e\n  \u003cul\u003e\n    \u003cli\u003e\n      \u003cspan\u003egetFriendRequests()\u003c/span\u003e: returns\n      \u003cspan\u003eaddress[]\u003c/span\u003e containing the addresses of users that have sent\n      this user a request that they have yet to accept (i.e., don't return\n      accepted requests).\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003egetNumberOfFriends()\u003c/span\u003e: returns a \u003cspan\u003euint\u003c/span\u003e value\n      representing the number of friends the calling user has.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003egetFriends()\u003c/span\u003e: returns \u003cspan\u003eaddress[]\u003c/span\u003e\n      containing the addresses of the calling users friends.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003esendFriendRequest(address friend)\u003c/span\u003e: sends a friend request to\n      the provided \u003cspan\u003eaddress\u003c/span\u003e.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003eacceptFriendRequest(address friend)\u003c/span\u003e: accepts a pending friend\n      request.\n    \u003c/li\u003e\n  \u003c/ul\u003e\n  \u003cp\u003e\n    Make sure all of the functions above are \u003cspan\u003epublic\u003c/span\u003e and have the\n    correct signature. You may add as many other functions, types, structs,\n    enums etc. as you like.\n  \u003c/p\u003e\n\u003c/div\u003e","releaseDate":"2022-05-24T00:00:00Z","resources":{"solidity":{"language":"solidity","sandboxCode":"// This suite of tests is written to run against your code\n// so that we can check its correctness.\n\nconst { assert } = require(\"chai\");\n\nconst Friends = artifacts.require(\"Friends\");\n\ncontract(\"Friends\", (accounts) =\u003e {\n  let instance;\n  const acc1 = accounts[1];\n  const acc2 = accounts[2];\n  const acc3 = accounts[3];\n\n  before(async () =\u003e {\n    instance = await Friends.deployed();\n  });\n\n  it(\"can send friend request\", async () =\u003e {\n    await instance.sendFriendRequest(acc2, { from: acc1 });\n    const result = await instance.getFriendRequests({ from: acc2 });\n    assert.ok(\n      result.includes(acc1),\n      \"acc2 should have friend request from acc1\"\n    );\n  });\n\n  it(\"cannot send duplicate friend request\", async () =\u003e {\n    try {\n      await instance.sendFriendRequest(acc2, { from: acc1 });\n      assert.ok(false, \"sending duplicate request should fail\");\n    } catch {\n      return;\n    }\n  });\n\n  it(\"cannot send friend request to self\", async () =\u003e {\n    try {\n      await instance.sendFriendRequest(acc2, { from: acc2 });\n      assert.ok(false, \"sending request to self should fail\");\n    } catch {\n      return;\n    }\n  });\n\n  it(\"cannot accept request that doesn't exist\", async () =\u003e {\n    try {\n      await instance.acceptFriendRequest(acc2, { from: acc2 });\n      assert.ok(false, \"accepting request that doesn't exist should fail\");\n    } catch {\n      return;\n    }\n  });\n\n  it(\"getNumberOfFriends returns accurate number\", async () =\u003e {\n    const result = await instance.getNumberOfFriends({ from: acc1 });\n    assert.equal(0, result, \"acc2 should have 0 friends\");\n  });\n\n  it(\"getFriends returns accurate friends\", async () =\u003e {\n    const result = await instance.getFriends({ from: acc1 });\n    assert.equal(0, result, \"acc2 should have 0 friends\");\n  });\n\n  it(\"can accept friend request \", async () =\u003e {\n    await instance.acceptFriendRequest(acc1, { from: acc2 });\n    const acc1Friends = await instance.getNumberOfFriends({ from: acc2 });\n    const acc2Friends = await instance.getNumberOfFriends({ from: acc2 });\n    assert.equal(1, acc1Friends, \"acc1 should have 1 friend\");\n    assert.equal(1, acc2Friends, \"acc2 should have 1 friend\");\n\n    const acc1FriendList = await instance.getFriends({ from: acc1 });\n    const acc2FriendList = await instance.getFriends({ from: acc2 });\n    assert.ok(acc1FriendList.includes(acc2), \"acc1 should have acc2 as friend\");\n    assert.ok(acc2FriendList.includes(acc1), \"acc2 should have acc1 as friend\");\n  });\n\n  it(\"has correct friend requests\", async () =\u003e {\n    const result = await instance.getFriendRequests({ from: acc1 });\n    assert.equal(0, result.length, \"acc1 should have no friend requests\");\n  });\n\n  it(\"cannot send friend request to friend\", async () =\u003e {\n    try {\n      await instance.sendFriendRequest(acc2, { from: acc1 });\n      assert.ok(false, \"sending request to existing friend should fail\");\n    } catch {\n      return;\n    }\n  });\n\n  it(\"can send 2nd friend request\", async () =\u003e {\n    await instance.sendFriendRequest(acc3, { from: acc1 });\n    const result = await instance.getFriendRequests({ from: acc3 });\n    assert.ok(\n      result.includes(acc1),\n      \"acc3 should have friend request from acc1\"\n    );\n  });\n\n  it(\"can accept friend request \", async () =\u003e {\n    await instance.acceptFriendRequest(acc1, { from: acc3 });\n    const acc1Friends = await instance.getNumberOfFriends({ from: acc1 });\n    const acc3Friends = await instance.getNumberOfFriends({ from: acc3 });\n    assert.equal(2, acc1Friends, \"acc1 should have 2 friends\");\n    assert.equal(1, acc3Friends, \"acc3 should have 1 friend\");\n\n    const acc1FriendList = await instance.getFriends({ from: acc1 });\n    const acc3FriendList = await instance.getFriends({ from: acc3 });\n    assert.ok(acc1FriendList.includes(acc3), \"acc1 should have acc3 as friend\");\n    assert.ok(acc1FriendList.includes(acc2), \"acc1 should have acc2 as friend\");\n    assert.ok(acc3FriendList.includes(acc1), \"acc2 should have acc1 as friend\");\n  });\n});\n","solutions":["// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npragma solidity \u003e=0.4.22 \u003c=0.8.17;\n\ncontract Friends {\n    struct Person {\n        address[] friends;\n        address[] requestsSent;\n        address[] requestsReceived;\n    }\n\n    mapping(address =\u003e Person) people;\n\n    function arrayContains(address[] memory array, address target)\n        internal\n        pure\n        returns (bool)\n    {\n        for (uint256 idx; idx \u003c array.length; idx++) {\n            if (array[idx] == target) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function deleteFromArray(address[] storage array, address target) internal {\n        uint256 targetIdx;\n        for (uint256 idx; idx \u003c array.length; idx++) {\n            if (array[idx] == target) {\n                targetIdx = idx;\n                break;\n            }\n        }\n\n        uint256 lastIdx = array.length - 1;\n        address lastValue = array[lastIdx];\n        array[lastIdx] = target;\n        array[targetIdx] = lastValue;\n        array.pop();\n    }\n\n    modifier requestNotSent(address friend) {\n        address[] memory requestsSent = people[msg.sender].requestsSent;\n        require(\n            !arrayContains(requestsSent, friend),\n            \"you have already sent this user a request\"\n        );\n        _;\n    }\n\n    modifier requestNotReceived(address friend) {\n        address[] memory requestsReceived = people[msg.sender].requestsReceived;\n        require(\n            !arrayContains(requestsReceived, friend),\n            \"this user has already sent you a request\"\n        );\n        _;\n    }\n\n    modifier requestExists(address friend) {\n        address[] memory requestsReceived = people[msg.sender].requestsReceived;\n        require(\n            arrayContains(requestsReceived, friend),\n            \"this user has not sent you a request\"\n        );\n        _;\n    }\n\n    modifier notAlreadyFriends(address friend) {\n        address[] memory friends = people[msg.sender].friends;\n        require(\n            !arrayContains(friends, friend),\n            \"you are already friends with this user\"\n        );\n        _;\n    }\n\n    modifier notSelf(address friend) {\n        require(\n            friend != msg.sender,\n            \"you cannot send a friend request to yourself\"\n        );\n        _;\n    }\n\n    function getFriendRequests() public view returns (address[] memory) {\n        return people[msg.sender].requestsReceived;\n    }\n\n    function getNumberOfFriends() public view returns (uint256) {\n        return people[msg.sender].friends.length;\n    }\n\n    function sendFriendRequest(address friend)\n        public\n        requestNotSent(friend)\n        requestNotReceived(friend)\n        notAlreadyFriends(friend)\n        notSelf(friend)\n    {\n        people[msg.sender].requestsSent.push(friend);\n        people[friend].requestsReceived.push(msg.sender);\n    }\n\n    function acceptFriendRequest(address friend) public requestExists(friend) {\n        deleteFromArray(people[msg.sender].requestsReceived, friend);\n        deleteFromArray(people[friend].requestsSent, msg.sender);\n        people[msg.sender].friends.push(friend);\n        people[friend].friends.push(msg.sender);\n    }\n\n    function getFriends() public view returns (address[] memory) {\n        return people[msg.sender].friends;\n    }\n}\n"],"solutionsDisabled":false,"startingCode":"pragma solidity \u003e=0.4.22 \u003c=0.8.17;\n\ncontract Friends {\n    // Write your code here\n}\n","unitTests":"const { assert } = require(\"chai\");\n\nconst Friends = artifacts.require(\"Friends\");\n\ncontract(\"Friends\", (accounts) =\u003e {\n  let instance;\n  const acc1 = accounts[1];\n  const acc2 = accounts[2];\n  const acc3 = accounts[3];\n\n  before(async () =\u003e {\n    instance = await Friends.deployed();\n  });\n\n  it(\"can send friend request\", async () =\u003e {\n    await instance.sendFriendRequest(acc2, { from: acc1 });\n    const result = await instance.getFriendRequests({ from: acc2 });\n    assert.ok(\n      result.includes(acc1),\n      \"acc2 should have friend request from acc1\"\n    );\n  });\n\n  it(\"cannot send duplicate friend request\", async () =\u003e {\n    try {\n      await instance.sendFriendRequest(acc2, { from: acc1 });\n      assert.ok(false, \"sending duplicate request should fail\");\n    } catch {\n      return;\n    }\n  });\n\n  it(\"cannot send friend request to self\", async () =\u003e {\n    try {\n      await instance.sendFriendRequest(acc2, { from: acc2 });\n      assert.ok(false, \"sending request to self should fail\");\n    } catch {\n      return;\n    }\n  });\n\n  it(\"cannot accept request that doesn't exist\", async () =\u003e {\n    try {\n      await instance.acceptFriendRequest(acc2, { from: acc2 });\n      assert.ok(false, \"accepting request that doesn't exist should fail\");\n    } catch {\n      return;\n    }\n  });\n\n  it(\"getNumberOfFriends returns accurate number\", async () =\u003e {\n    const result = await instance.getNumberOfFriends({ from: acc1 });\n    assert.equal(0, result, \"acc2 should have 0 friends\");\n  });\n\n  it(\"getFriends returns accurate friends\", async () =\u003e {\n    const result = await instance.getFriends({ from: acc1 });\n    assert.equal(0, result, \"acc2 should have 0 friends\");\n  });\n\n  it(\"can accept friend request \", async () =\u003e {\n    await instance.acceptFriendRequest(acc1, { from: acc2 });\n    const acc1Friends = await instance.getNumberOfFriends({ from: acc2 });\n    const acc2Friends = await instance.getNumberOfFriends({ from: acc2 });\n    assert.equal(1, acc1Friends, \"acc1 should have 1 friend\");\n    assert.equal(1, acc2Friends, \"acc2 should have 1 friend\");\n\n    const acc1FriendList = await instance.getFriends({ from: acc1 });\n    const acc2FriendList = await instance.getFriends({ from: acc2 });\n    assert.ok(acc1FriendList.includes(acc2), \"acc1 should have acc2 as friend\");\n    assert.ok(acc2FriendList.includes(acc1), \"acc2 should have acc1 as friend\");\n  });\n\n  it(\"has correct friend requests\", async () =\u003e {\n    const result = await instance.getFriendRequests({ from: acc1 });\n    assert.equal(0, result.length, \"acc1 should have no friend requests\");\n  });\n\n  it(\"cannot send friend request to friend\", async () =\u003e {\n    try {\n      await instance.sendFriendRequest(acc2, { from: acc1 });\n      assert.ok(false, \"sending request to existing friend should fail\");\n    } catch {\n      return;\n    }\n  });\n\n  it(\"can send 2nd friend request\", async () =\u003e {\n    await instance.sendFriendRequest(acc3, { from: acc1 });\n    const result = await instance.getFriendRequests({ from: acc3 });\n    assert.ok(\n      result.includes(acc1),\n      \"acc3 should have friend request from acc1\"\n    );\n  });\n\n  it(\"can accept friend request \", async () =\u003e {\n    await instance.acceptFriendRequest(acc1, { from: acc3 });\n    const acc1Friends = await instance.getNumberOfFriends({ from: acc1 });\n    const acc3Friends = await instance.getNumberOfFriends({ from: acc3 });\n    assert.equal(2, acc1Friends, \"acc1 should have 2 friends\");\n    assert.equal(1, acc3Friends, \"acc3 should have 1 friend\");\n\n    const acc1FriendList = await instance.getFriends({ from: acc1 });\n    const acc3FriendList = await instance.getFriends({ from: acc3 });\n    assert.ok(acc1FriendList.includes(acc3), \"acc1 should have acc3 as friend\");\n    assert.ok(acc1FriendList.includes(acc2), \"acc1 should have acc2 as friend\");\n    assert.ok(acc3FriendList.includes(acc1), \"acc2 should have acc1 as friend\");\n  });\n});\n"}},"spaceTime":"","submissionStatistics":{"correctCount":309,"failureCount":1668},"testStrategy":"SANDBOX_ONLY","tests":[],"uid":"friend-requests","version":0,"video":{"annotations":[],"codeWalkthroughTime":null,"duration":0,"instructor":"","overviewTime":null,"vimeoId":"765855597"},"visualization":{"inputType":null,"outputType":null}},"difficulty":0,"instructor":"","name":"Friend Requests","releaseDate":"2022-05-24T00:00:00Z","type":"CODING_STANDARD","uid":"friend-requests"},{"acl":{"isAvailable":true,"isFree":false,"isFreeForStudents":false,"productRequired":["blockchainexpert"]},"category":"Solidity","contents":{"acl":{"isAvailable":true,"isFree":false,"isFreeForStudents":false,"productRequired":["blockchainexpert"]},"assessmentSummary":null,"category":"Solidity","changelog":[],"customInputVars":[],"difficulty":0,"hints":[],"isLongOutput":false,"isSlowExecution":false,"jsonTests":[],"languagesSupported":["solidity"],"name":"Blockchain Workplace","notes":"","prompt":"\u003cdiv class=\"html\"\u003e\n  \u003cp\u003e\n    Write a smart contract named \u003cspan\u003eEmployee\u003c/span\u003e and a smart contract that\n    inherits from \u003cspan\u003eEmployee\u003c/span\u003e named \u003cspan\u003eManager\u003c/span\u003e. Managers\n    share all the properties of employees but have subordinates which may be\n    other managers or employees.\n  \u003c/p\u003e\n  \u003cp\u003e\n    Each \u003cspan\u003eEmployee\u003c/span\u003e instance is initialized (using the constructor) by\n    passing a \u003cspan\u003estring firstName\u003c/span\u003e, \u003cspan\u003estring lastName\u003c/span\u003e,\n    \u003cspan\u003euint hourlyPay\u003c/span\u003e and a \u003cspan\u003euint department\u003c/span\u003e, in this\n    order. Use an enum to represent the valid departments of\n    \u003cspan\u003eGardening\u003c/span\u003e, \u003cspan\u003eClothing\u003c/span\u003e and \u003cspan\u003eTools\u003c/span\u003e, in\n    that order. Each \u003cspan\u003eManager\u003c/span\u003e instance is initialized the same as an\n    employee.\n  \u003c/p\u003e\n  \u003cp\u003e\n    The \u003cspan\u003eEmployee\u003c/span\u003e contract should implement the following functions.\n  \u003c/p\u003e\n  \u003cul\u003e\n    \u003cli\u003e\n      \u003cspan\u003egetWeeklyPay(uint hoursWorked)\u003c/span\u003e: returns a\n      \u003cspan\u003euint\u003c/span\u003e representing the amount this employee should be paid\n      based on their hourly rate and the \u003cspan\u003ehours\u003c/span\u003e worked. This\n      function should factor in overtime pay. For every hour beyhond\n      \u003cspan\u003e40\u003c/span\u003e that the employee works they should be paid double their\n      hourly rate. For example, if an employee makes $20/hour and works 42 hours\n      they are paid $880.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003egetFirstName()\u003c/span\u003e: returns a \u003cspan\u003estring\u003c/span\u003e representing\n      the first name of the employee.\n    \u003c/li\u003e\n  \u003c/ul\u003e\n  \u003cp\u003e\n    The \u003cspan\u003eManager\u003c/span\u003e contract should implement the following functions.\n  \u003c/p\u003e\n  \u003cul\u003e\n    \u003cli\u003e\n      \u003cspan\u003eaddSubordinate(string firstName, string lastName, uint hourlyPay, Department department)\u003c/span\u003e: this function takes the required arguments to create a new employee and\n      adds this employee to this managers subordinates.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003egetSubordinates()\u003c/span\u003e: this function should return a\n      \u003cspan\u003estring[]\u003c/span\u003e containing the first names of all of its\n      subordinates.\n    \u003c/li\u003e\n  \u003c/ul\u003e\n  \u003cp\u003e\n    Note: you do not need to handle any edge cases like managers having\n    duplicate subordinates.\n  \u003c/p\u003e\n\u003c/div\u003e","releaseDate":"2022-05-24T00:00:00Z","resources":{"solidity":{"language":"solidity","sandboxCode":"// This suite of tests is written to run against your code\n// so that we can check its correctness.\n\nconst { assert } = require(\"chai\");\n\nconst Employee = artifacts.require(\"Employee\");\nconst Manager = artifacts.require(\"Manager\");\n\ncontract(\"Blockchain Workplace\", (accounts) =\u003e {\n  let employee;\n  let manager;\n\n  before(async () =\u003e {\n    employee = await Employee.deployed();\n    manager = await Manager.deployed();\n  });\n\n  it(\"employee returns correct name\", async () =\u003e {\n    const name = await employee.getFirstName();\n    assert.equal(\"Employee\", name, \"Employee 1 name should be Employee\");\n  });\n\n  it(\"employee returns correct pay\", async () =\u003e {\n    const pay = await employee.getWeeklyPay(40); // $30/hour\n    assert.equal(1200, pay, \"pay should be\");\n  });\n\n  it(\"manager returns correct pay\", async () =\u003e {\n    const pay = await manager.getWeeklyPay(35); // $40/hour\n    assert.equal(1400, pay, \"pay should be\");\n  });\n\n  it(\"manager returns correct pay 2\", async () =\u003e {\n    const pay = await manager.getWeeklyPay(90); // $40/hour\n    assert.equal(5600, pay, \"pay should be\");\n  });\n\n  it(\"can add subordinate\", async () =\u003e {\n    await manager.addSubordinate(\"Employee\", \"employee\", 30, 1);\n    const names = await manager.getSubordinates();\n    assert.ok(names.includes(\"Employee\"), \"Employee should be a subordinate\");\n  });\n\n  it(\"can add 2nd subordinate\", async () =\u003e {\n    await manager.addSubordinate(\"Employee2\", \"employee\", 40, 1);\n    const names = await manager.getSubordinates();\n    assert.ok(names.includes(\"Employee\"), \"Employee should be a subordinate\");\n    assert.ok(names.includes(\"Employee2\"), \"Employee2 should be a subordinate\");\n  });\n});\n","solutions":["// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npragma solidity \u003e=0.4.22 \u003c=0.8.17;\n\ncontract Employee {\n    enum Depratment {\n        Gardening,\n        Clothing,\n        Tools\n    }\n\n    string firstName;\n    string lastName;\n    uint256 hourlyPay;\n    Depratment deprartment;\n\n    constructor(\n        string memory _firstName,\n        string memory _lastName,\n        uint256 _hourlyPay,\n        Depratment _department\n    ) {\n        firstName = _firstName;\n        lastName = _lastName;\n        hourlyPay = _hourlyPay;\n        deprartment = _department;\n    }\n\n    function getWeeklyPay(uint256 hoursWorked) public view returns (uint256) {\n        if (hoursWorked \u003c= 40) {\n            return hourlyPay * hoursWorked;\n        }\n        uint256 overtimeHours = hoursWorked - 40;\n        return 40 * hourlyPay + (overtimeHours * 2 * hourlyPay);\n    }\n\n    function getFirstName() public view returns (string memory) {\n        return firstName;\n    }\n}\n\ncontract Manager is Employee {\n    Employee[] subordinates;\n\n    constructor(\n        string memory _firstName,\n        string memory _lastName,\n        uint256 _hourlyPay,\n        Depratment _department\n    ) Employee(_firstName, _lastName, _hourlyPay, _department) {}\n\n    function addSubordinate(\n        string memory _firstName,\n        string memory _lastName,\n        uint256 _hourlyPay,\n        Depratment _department\n    ) public {\n        Employee employee = new Employee(\n            _firstName,\n            _lastName,\n            _hourlyPay,\n            _department\n        );\n        subordinates.push(employee);\n    }\n\n    function getSubordinates() public view returns (string[] memory) {\n        string[] memory names = new string[](subordinates.length);\n        for (uint256 idx; idx \u003c subordinates.length; idx++) {\n            names[idx] = subordinates[idx].getFirstName();\n        }\n        return names;\n    }\n}\n"],"solutionsDisabled":false,"startingCode":"pragma solidity \u003e=0.4.22 \u003c=0.8.17;\n\ncontract Employee {\n    // Write your code here\n}\n\ncontract Manager is Employee {\n    // Write tour code here\n}","unitTests":"const { assert } = require(\"chai\");\n\nconst Employee = artifacts.require(\"Employee\");\nconst Manager = artifacts.require(\"Manager\");\n\ncontract(\"Blockchain Workplace\", (accounts) =\u003e {\n  let employee;\n  let manager;\n\n  before(async () =\u003e {\n    employee = await Employee.deployed();\n    manager = await Manager.deployed();\n  });\n\n  it(\"employee returns correct name\", async () =\u003e {\n    const name = await employee.getFirstName();\n    assert.equal(\"Employee\", name, \"Employee 1 name should be Employee\");\n  });\n\n  it(\"employee returns correct pay\", async () =\u003e {\n    const pay = await employee.getWeeklyPay(40); // $30/hour\n    assert.equal(1200, pay, \"pay should be\");\n  });\n\n  it(\"manager returns correct pay\", async () =\u003e {\n    const pay = await manager.getWeeklyPay(35); // $40/hour\n    assert.equal(1400, pay, \"pay should be\");\n  });\n\n  it(\"manager returns correct pay 2\", async () =\u003e {\n    const pay = await manager.getWeeklyPay(90); // $40/hour\n    assert.equal(5600, pay, \"pay should be\");\n  });\n\n  it(\"can add subordinate\", async () =\u003e {\n    await manager.addSubordinate(\"Employee\", \"employee\", 30, 1);\n    const names = await manager.getSubordinates();\n    assert.ok(names.includes(\"Employee\"), \"Employee should be a subordinate\");\n  });\n\n  it(\"can add 2nd subordinate\", async () =\u003e {\n    await manager.addSubordinate(\"Employee2\", \"employee\", 40, 1);\n    const names = await manager.getSubordinates();\n    assert.ok(names.includes(\"Employee\"), \"Employee should be a subordinate\");\n    assert.ok(names.includes(\"Employee2\"), \"Employee2 should be a subordinate\");\n  });\n});\n"}},"spaceTime":"","submissionStatistics":{"correctCount":310,"failureCount":1480},"testStrategy":"SANDBOX_ONLY","tests":[],"uid":"solidity-workplace","version":0,"video":{"annotations":[],"codeWalkthroughTime":null,"duration":0,"instructor":"","overviewTime":null,"vimeoId":"765854832"},"visualization":{"inputType":null,"outputType":null}},"difficulty":0,"instructor":"","name":"Blockchain Workplace","releaseDate":"2022-05-24T00:00:00Z","type":"CODING_STANDARD","uid":"solidity-workplace"},{"acl":{"isAvailable":true,"isFree":false,"isFreeForStudents":false,"productRequired":["blockchainexpert"]},"category":"Solidity","contents":{"acl":{"isAvailable":true,"isFree":false,"isFreeForStudents":false,"productRequired":["blockchainexpert"]},"assessmentSummary":null,"category":"Solidity","changelog":[],"customInputVars":[],"difficulty":0,"hints":[],"isLongOutput":false,"isSlowExecution":false,"jsonTests":[],"languagesSupported":["solidity"],"name":"Score Tracker","notes":"","prompt":"\u003cdiv class=\"html\"\u003e\n  \u003cp\u003e\n    For this question you'll be asked to write a set of contracts that will\n    allow you to track the winning teams across multiple types of games.\n  \u003c/p\u003e\n  \u003cp\u003e\n    Start by writing an \u003cspan\u003eabstract\u003c/span\u003e contract named\n    \u003cspan\u003eGame\u003c/span\u003e that will implement the base functionality for all games.\n    This contract should be initialized by passing the\n    \u003cspan\u003estring homeTeam\u003c/span\u003e and the \u003cspan\u003estring awayTeam\u003c/span\u003e. It should\n    also include the following functions.\n  \u003c/p\u003e\n  \u003cul\u003e\n    \u003cli\u003e\n      \u003cspan\u003egetHomeTeamScore()\u003c/span\u003e: an abstract internal function that\n      returns the \u003cspan\u003euint\u003c/span\u003e score of the home team. This function should\n      be overridden by any child contracts.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003egetAwayTeamScore()\u003c/span\u003e: an abstract internal function that\n      returns the \u003cspan\u003euint\u003c/span\u003e score of the away team. This function should\n      be overridden by any child contracts.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003egetWinningTeam()\u003c/span\u003e: a public concrete function that returns the\n      \u003cspan\u003estring\u003c/span\u003e name of the winning team for this game.\n    \u003c/li\u003e\n  \u003c/ul\u003e\n  \u003cp\u003e\n    After completing this contract write the following two children contracts\n    named \u003cspan\u003eBasketballGame\u003c/span\u003e and \u003cspan\u003eSoccerGame\u003c/span\u003e that inherit\n    from \u003cspan\u003eGame\u003c/span\u003e.\n  \u003c/p\u003e\n  \u003cp\u003e\n    The \u003cspan\u003eBasketballGame\u003c/span\u003e contract should override the necessary\n    functions from \u003cspan\u003eGame\u003c/span\u003e and implement the following additional\n    functions.\n  \u003c/p\u003e\n  \u003cul\u003e\n    \u003cli\u003e\n      \u003cspan\u003ehomeTeamScored(uint score)\u003c/span\u003e: this external function should\n      increment the home teams score by the passed \u003cspan\u003escore\u003c/span\u003e. The only\n      valid scores are \u003cspan\u003e1\u003c/span\u003e, \u003cspan\u003e2\u003c/span\u003e and \u003cspan\u003e3\u003c/span\u003e, the\n      function should fail if you pass an invalid score.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003eawayTeamScored(uint score)\u003c/span\u003e: this external function should\n      increment the away teams score by the passed \u003cspan\u003escore\u003c/span\u003e. The only\n      valid scores are \u003cspan\u003e1\u003c/span\u003e, \u003cspan\u003e2\u003c/span\u003e and \u003cspan\u003e3\u003c/span\u003e, the\n      function should fail if you pass an invalid score.\n    \u003c/li\u003e\n  \u003c/ul\u003e\n  \u003cp\u003e\n    The \u003cspan\u003eSoccerGame\u003c/span\u003e contract should override the necessary functions\n    from \u003cspan\u003eGame\u003c/span\u003e and implement the following additional functions.\n  \u003c/p\u003e\n  \u003cli\u003e\n    \u003cspan\u003ehomeTeamScored()\u003c/span\u003e: this external function should increment the\n    home teams score by one.\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cspan\u003eawayTeamScored()\u003c/span\u003e: this external function should increment the\n    away teams score by one.\n  \u003c/li\u003e\n  \u003cp\u003e\n    Make sure to use the correct function signatures, contract names, visibility\n    modifiers and parameter/return value types.\n  \u003c/p\u003e\n\u003c/div\u003e","releaseDate":"2022-05-24T00:00:00Z","resources":{"solidity":{"language":"solidity","sandboxCode":"// This suite of tests is written to run against your code\n// so that we can check its correctness.\n\nconst { assert } = require(\"chai\");\n\nconst basketballC = artifacts.require(\"BasketballGame\");\nconst soccerC = artifacts.require(\"SoccerGame\");\n\ncontract(\"ScoreTracker\", (accounts) =\u003e {\n  let basketball;\n  let soccer;\n\n  before(async () =\u003e {\n    basketball = await basketballC.deployed();\n    soccer = await soccerC.deployed();\n  });\n\n  describe(\"BasketballGame\", async () =\u003e {\n    it(\"homeTeamScored() doesn't accept invalid score\", async () =\u003e {\n      try {\n        await basketball.homeTeamScored(4);\n        assert.ok(false, \"homeTeamScored(4) should fail\");\n      } catch {\n        return;\n      }\n    });\n\n    it(\"homeTeamScored() doesn't accept invalid score 2\", async () =\u003e {\n      try {\n        await basketball.homeTeamScored(0);\n        assert.ok(false, \"homeTeamScored(0) should fail\");\n      } catch {\n        return;\n      }\n    });\n\n    it(\"awayTeamScored() doesn't accept invalid score\", async () =\u003e {\n      try {\n        await basketball.awayTeamScored(4);\n        assert.ok(false, \"awayTeamScored(4) should fail\");\n      } catch {\n        return;\n      }\n    });\n\n    it(\"awayTeamScored() doesn't accept invalid score 2\", async () =\u003e {\n      try {\n        await basketball.awayTeamScored(0);\n        assert.ok(false, \"awayTeamScored(0) should fail\");\n      } catch {\n        return;\n      }\n    });\n\n    it(\"homeTeamScored() works with valid score 1\", async () =\u003e {\n      await basketball.homeTeamScored(1);\n    });\n\n    it(\"homeTeamScored() works with valid score 2\", async () =\u003e {\n      await basketball.homeTeamScored(2);\n    });\n\n    it(\"homeTeamScored() works with valid score 3\", async () =\u003e {\n      await basketball.homeTeamScored(3);\n    });\n\n    it(\"awayTeamScored() works with valid score 1\", async () =\u003e {\n      await basketball.awayTeamScored(1);\n    });\n\n    it(\"awayTeamScored() works with valid score 2\", async () =\u003e {\n      await basketball.awayTeamScored(2);\n    });\n\n    it(\"awayTeamScored() works with valid score 3 \", async () =\u003e {\n      await basketball.awayTeamScored(3);\n    });\n\n    it(\"awayTeamScored() works with valid score 4 \", async () =\u003e {\n      await basketball.awayTeamScored(1);\n    });\n  });\n\n  describe(\"SoccerGame\", () =\u003e { \n    it(\"homeTeamScore() works\", async () =\u003e { \n      await soccer.homeTeamScored();\n    })\n\n    it(\"awayTeamScore() works\", async () =\u003e { \n      await soccer.awayTeamScored();\n    })\n\n    it(\"awayTeamScore() works\", async () =\u003e { \n      await soccer.awayTeamScored();\n    })\n  })\n\n});\n","solutions":["// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npragma solidity \u003e=0.4.22 \u003c=0.8.17;\n\nabstract contract Game {\n    string homeTeam;\n    string awayTeam;\n\n    constructor(string memory _homeTeam, string memory _awayTeam) {\n        homeTeam = _homeTeam;\n        awayTeam = _awayTeam;\n    }\n\n    function getHomeTeamScore() internal view virtual returns (uint256);\n\n    function getAwayTeamScore() internal view virtual returns (uint256);\n\n    function getWinningTeam() public view returns (string memory) {\n        if (getHomeTeamScore() \u003e getAwayTeamScore()) {\n            return homeTeam;\n        } else {\n            return awayTeam;\n        }\n    }\n}\n\ncontract BasketballGame is Game {\n    uint256 homeTeamScore;\n    uint256 awayTeamScore;\n\n    constructor(string memory _homeTeam, string memory _awayTeam)\n        Game(_homeTeam, _awayTeam)\n    {}\n\n    modifier validScore(uint256 score) {\n        require(score \u003e 0 \u0026\u0026 score \u003c 4, \"invalid score\");\n        _;\n    }\n\n    function getHomeTeamScore() internal view override returns (uint256) {\n        return homeTeamScore;\n    }\n\n    function getAwayTeamScore() internal view override returns (uint256) {\n        return awayTeamScore;\n    }\n\n    function homeTeamScored(uint256 score) external validScore(score) {\n        homeTeamScore += score;\n    }\n\n    function awayTeamScored(uint256 score) external validScore(score) {\n        awayTeamScore += score;\n    }\n}\n\ncontract SoccerGame is Game {\n    uint256 homeTeamScore;\n    uint256 awayTeamScore;\n\n    constructor(string memory _homeTeam, string memory _awayTeam)\n        Game(_homeTeam, _awayTeam)\n    {}\n\n    function getHomeTeamScore() internal view override returns (uint256) {\n        return homeTeamScore;\n    }\n\n    function getAwayTeamScore() internal view override returns (uint256) {\n        return awayTeamScore;\n    }\n\n    function homeTeamScored() external {\n        homeTeamScore++;\n    }\n\n    function awayTeamScored() external {\n        awayTeamScore++;\n    }\n}\n"],"solutionsDisabled":false,"startingCode":"pragma solidity \u003e=0.4.22 \u003c=0.8.17;\n\nabstract contract Game {\n    // Write your code here\n}\n\ncontract BasketballGame is Game {\n    // Write your code here\n}\n\ncontract SoccerGame is Game {\n    // Write your code here\n}\n","unitTests":"const { assert } = require(\"chai\");\n\nconst basketballC = artifacts.require(\"BasketballGame\");\nconst soccerC = artifacts.require(\"SoccerGame\");\n\ncontract(\"ScoreTracker\", (accounts) =\u003e {\n  let basketball;\n  let soccer;\n\n  before(async () =\u003e {\n    basketball = await basketballC.deployed();\n    soccer = await soccerC.deployed();\n  });\n\n  describe(\"BasketballGame\", async () =\u003e {\n    it(\"homeTeamScored() doesn't accept invalid score\", async () =\u003e {\n      try {\n        await basketball.homeTeamScored(4);\n        assert.ok(false, \"homeTeamScored(4) should fail\");\n      } catch {\n        return;\n      }\n    });\n\n    it(\"homeTeamScored() doesn't accept invalid score 2\", async () =\u003e {\n      try {\n        await basketball.homeTeamScored(0);\n        assert.ok(false, \"homeTeamScored(0) should fail\");\n      } catch {\n        return;\n      }\n    });\n\n    it(\"awayTeamScored() doesn't accept invalid score\", async () =\u003e {\n      try {\n        await basketball.awayTeamScored(4);\n        assert.ok(false, \"awayTeamScored(4) should fail\");\n      } catch {\n        return;\n      }\n    });\n\n    it(\"awayTeamScored() doesn't accept invalid score 2\", async () =\u003e {\n      try {\n        await basketball.awayTeamScored(0);\n        assert.ok(false, \"awayTeamScored(0) should fail\");\n      } catch {\n        return;\n      }\n    });\n\n    it(\"homeTeamScored() works with valid score 1\", async () =\u003e {\n      await basketball.homeTeamScored(1);\n    });\n\n    it(\"homeTeamScored() works with valid score 2\", async () =\u003e {\n      await basketball.homeTeamScored(2);\n    });\n\n    it(\"homeTeamScored() works with valid score 3\", async () =\u003e {\n      await basketball.homeTeamScored(3);\n    });\n\n    it(\"awayTeamScored() works with valid score 1\", async () =\u003e {\n      await basketball.awayTeamScored(1);\n    });\n\n    it(\"awayTeamScored() works with valid score 2\", async () =\u003e {\n      await basketball.awayTeamScored(2);\n    });\n\n    it(\"awayTeamScored() works with valid score 3 \", async () =\u003e {\n      await basketball.awayTeamScored(3);\n    });\n\n    it(\"awayTeamScored() works with valid score 4 \", async () =\u003e {\n      await basketball.awayTeamScored(1);\n    });\n  });\n\n  describe(\"SoccerGame\", () =\u003e { \n    it(\"homeTeamScore() works\", async () =\u003e { \n      await soccer.homeTeamScored();\n    })\n\n    it(\"awayTeamScore() works\", async () =\u003e { \n      await soccer.awayTeamScored();\n    })\n\n    it(\"awayTeamScore() works\", async () =\u003e { \n      await soccer.awayTeamScored();\n    })\n  })\n\n});\n"}},"spaceTime":"","submissionStatistics":{"correctCount":309,"failureCount":695},"testStrategy":"SANDBOX_ONLY","tests":[],"uid":"score-tracker","version":0,"video":{"annotations":[],"codeWalkthroughTime":null,"duration":0,"instructor":"","overviewTime":null,"vimeoId":"765854303"},"visualization":{"inputType":null,"outputType":null}},"difficulty":0,"instructor":"","name":"Score Tracker","releaseDate":"2022-05-24T00:00:00Z","type":"CODING_STANDARD","uid":"score-tracker"},{"acl":{"isAvailable":true,"isFree":false,"isFreeForStudents":false,"productRequired":["blockchainexpert"]},"category":"Solidity","contents":{"acl":{"isAvailable":true,"isFree":false,"isFreeForStudents":false,"productRequired":["blockchainexpert"]},"assessmentSummary":null,"category":"Solidity","changelog":[],"customInputVars":[],"difficulty":0,"hints":[],"isLongOutput":false,"isSlowExecution":false,"jsonTests":[],"languagesSupported":["solidity"],"name":"Blockchain Road Trip","notes":"","prompt":"\u003cdiv class=\"html\"\u003e\n  \u003cp\u003e\n    Write an interface named \u003cspan\u003eDriveable\u003c/span\u003e that defines the following\n    functions. Note that the descriptions for the functions are for when you\n    implement them in a contract.\n  \u003c/p\u003e\n  \u003cp\u003e\n    Use the correct visibility modifiers based on your experience with\n    interfaces.\n  \u003c/p\u003e\n  \u003cul\u003e\n    \u003cli\u003e\n      \u003cspan\u003estartEngine()\u003c/span\u003e: a function that puts the driveable contract\n      into the started state.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003estopEngine()\u003c/span\u003e: a function that puts the driveable contract\n      into the stopped state.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003efuelUp(uint litres)\u003c/span\u003e: a function that adds the provided\n      \u003cspan\u003elitres\u003c/span\u003e to the gas tank. This should only be callable when the\n      driveable contract is in a stopped state. This function should fail if\n      adding the provided \u003cspan\u003elitres\u003c/span\u003e causes the tank to exceed\n      capacity.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003edrive(uint kilometers)\u003c/span\u003e: a function that drives the car\n      \u003cspan\u003ekilometers\u003c/span\u003e distance and adjusts the remaining gas\n      accordingly. This function should only be callable in the started state.\n      This function should fail if the gas remaining is not sufficient to drive\n      the provided \u003cspan\u003ekilometers\u003c/span\u003e. Assume the provided kilometers will\n      always utilize a non-fractional number of litres (i.e., no need to handle\n      rounding errors when using division).\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003ekilometersRemaining() view returns (uint)\u003c/span\u003e: a function that\n      returns the driveable kilometers remaining based on the fuel level.\n    \u003c/li\u003e\n  \u003c/ul\u003e\n  \u003cp\u003e\n    Next, write an \u003cspan\u003eabstract\u003c/span\u003e contract named\n    \u003cspan\u003eGasVehicle\u003c/span\u003e that implements the\n    \u003cspan\u003eDriveable\u003c/span\u003e interface. This contract should also define the\n    following abstract functions (i.e., do not implement these functions).\n  \u003c/p\u003e\n  \u003cul\u003e\n    \u003cli\u003e\n      \u003cspan\u003egetKilometersPerLitre()\u003c/span\u003e: a public function that returns a\n      \u003cspan\u003euint\u003c/span\u003e representing the number of kilometers that can be driven\n      with one litre of gas.\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cspan\u003egetFuelCapacity()\u003c/span\u003e: a public function that returns a\n      \u003cspan\u003euint\u003c/span\u003e representing the maximum fuel tank capacity in litres.\n    \u003c/li\u003e\n  \u003c/ul\u003e\n  \u003cp\u003e\n    Lastly, write a \u003cspan\u003eCar\u003c/span\u003e contract that inherits from\n    \u003cspan\u003eGasVehicle\u003c/span\u003e and is initialzed by passing a\n    \u003cspan\u003euint fuelTankSize\u003c/span\u003e and a \u003cspan\u003euint kilometersPerLitre\u003c/span\u003e,\n    in that order. This contract should override the appropriate functions.\n  \u003c/p\u003e\n  \u003cp\u003e\n    Note: the \u003cspan\u003eCar\u003c/span\u003e should start with \u003cspan\u003e0\u003c/span\u003e litres of gas\n    and be in the stopped state.\n  \u003c/p\u003e\n\u003c/div\u003e","releaseDate":"2022-05-24T00:00:00Z","resources":{"solidity":{"language":"solidity","sandboxCode":"// This suite of tests is written to run against your code\n// so that we can check its correctness.\n\nconst { assert } = require(\"chai\");\n\nconst Car = artifacts.require(\"Car\");\n\ncontract(\"Car\", (accounts) =\u003e {\n  let instance;\n\n  before(async () =\u003e {\n    instance = await Car.deployed(); // fuelTankSize: 100, KilometersPerLitre: 10\n  });\n\n  it(\"can't drive when engine stopped\", async () =\u003e {\n    try {\n      await instance.drive(10);\n      assert.ok(false, \"can't drive when engine stopped\");\n    } catch {\n      return;\n    }\n  });\n\n  it(\"can start engine\", async () =\u003e {\n    await instance.startEngine();\n  });\n\n  it(\"can't drive when no gas\", async () =\u003e {\n    try {\n      await instance.drive(10);\n      assert.ok(false, \"can't drive when no gas\");\n    } catch {\n      return;\n    }\n  });\n\n  it(\"can't fuel up when started\", async () =\u003e {\n    try {\n      await instance.fuelUp(10);\n      assert.ok(false, \"should not be able to fuel up when started\");\n    } catch {\n      return;\n    }\n  });\n\n  it(\"can fuel up when stopped\", async () =\u003e {\n    await instance.stopEngine();\n    await instance.fuelUp(10);\n    const result = await instance.kilometersRemaining();\n    assert.equal(100, result, \"should have 100km\");\n  });\n\n  it(\"can't fuel up invalid amount\", async () =\u003e {\n    try {\n      await instance.fuelUp(100);\n      assert.ok(false, \"can't fuel up invalid amount\");\n    } catch {\n      return;\n    }\n  });\n\n  it(\"can't drive invalid amount\", async () =\u003e {\n    try {\n      await instance.startEngine();\n      await instance.drive(110);\n      assert.ok(false, \"can't drive invalid amount\");\n    } catch {\n      return;\n    }\n  });\n\n  it(\"can drive \", async () =\u003e {\n    await instance.stopEngine();\n    await instance.startEngine();\n    await instance.drive(100);\n    const result = await instance.kilometersRemaining();\n    assert.equal(0, result, \"should have 0km remaining\");\n  });\n\n  it(\"can fuel up when stopped 2\", async () =\u003e {\n    await instance.stopEngine();\n    await instance.fuelUp(25);\n    const result = await instance.kilometersRemaining();\n    assert.equal(250, result, \"should have 250km\");\n  });\n\n  it(\"can drive 2\", async () =\u003e {\n    await instance.startEngine();\n    await instance.drive(150);\n    const result = await instance.kilometersRemaining();\n    assert.equal(100, result, \"should have 100km remaining\");\n  });\n});\n","solutions":["// Copyright © 2023 AlgoExpert LLC. All rights reserved.\n\npragma solidity \u003e=0.4.22 \u003c=0.8.17;\n\ninterface Driveable {\n    function startEngine() external;\n\n    function stopEngine() external;\n\n    function fuelUp(uint256 litres) external;\n\n    function drive(uint256 kilometers) external;\n\n    function kilometersRemaining() external view returns (uint256);\n}\n\nabstract contract GasVehicle is Driveable {\n    uint256 litresRemaining;\n    bool started;\n\n    modifier sufficientTankSize(uint256 litres) {\n        require(litresRemaining + litres \u003c= getFuelCapacity());\n        _;\n    }\n\n    modifier sufficientKilometersRemaining(uint256 kilometers) {\n        require(kilometersRemaining() \u003e= litresRemaining);\n        _;\n    }\n\n    modifier notStarted() {\n        require(!started);\n        _;\n    }\n\n    modifier isStarted() {\n        require(started);\n        _;\n    }\n\n    function startEngine() external notStarted {\n        started = true;\n    }\n\n    function stopEngine() external isStarted {\n        started = false;\n    }\n\n    function fuelUp(uint256 litres)\n        external\n        sufficientTankSize(litres)\n        notStarted\n    {\n        litresRemaining += litres;\n    }\n\n    function drive(uint256 kilometers)\n        external\n        isStarted\n        sufficientKilometersRemaining(kilometers)\n    {\n        litresRemaining -= kilometers / getKilometersPerLitre();\n    }\n\n    function kilometersRemaining() public view returns (uint256) {\n        return litresRemaining * getKilometersPerLitre();\n    }\n\n    function getKilometersPerLitre() public view virtual returns (uint256);\n\n    function getFuelCapacity() public view virtual returns (uint256);\n}\n\ncontract Car is GasVehicle {\n    uint256 fuelTankSize;\n    uint256 kilometersPerLitre;\n\n    constructor(uint256 _fuelTankSize, uint256 _kilometersPerLitre) {\n        fuelTankSize = _fuelTankSize;\n        kilometersPerLitre = _kilometersPerLitre;\n    }\n\n    function getKilometersPerLitre() public view override returns (uint256) {\n        return kilometersPerLitre;\n    }\n\n    function getFuelCapacity() public view override returns (uint256) {\n        return fuelTankSize;\n    }\n}\n"],"solutionsDisabled":false,"startingCode":"pragma solidity \u003e=0.4.22 \u003c=0.8.17;\n\ninterface Driveable {\n    // Write your code here\n}\n\nabstract contract GasVehicle is Driveable {\n    // Write your code here\n}\n\ncontract Car is GasVehicle {\n    // Write your code here\n}\n","unitTests":"const { assert } = require(\"chai\");\n\nconst Car = artifacts.require(\"Car\");\n\ncontract(\"Car\", (accounts) =\u003e {\n  let instance;\n\n  before(async () =\u003e {\n    instance = await Car.deployed(); // fuelTankSize: 100, KilometersPerLitre: 10\n  });\n\n  it(\"can't drive when engine stopped\", async () =\u003e {\n    try {\n      await instance.drive(10);\n      assert.ok(false, \"can't drive when engine stopped\");\n    } catch {\n      return;\n    }\n  });\n\n  it(\"can start engine\", async () =\u003e {\n    await instance.startEngine();\n  });\n\n  it(\"can't drive when no gas\", async () =\u003e {\n    try {\n      await instance.drive(10);\n      assert.ok(false, \"can't drive when no gas\");\n    } catch {\n      return;\n    }\n  });\n\n  it(\"can't fuel up when started\", async () =\u003e {\n    try {\n      await instance.fuelUp(10);\n      assert.ok(false, \"should not be able to fuel up when started\");\n    } catch {\n      return;\n    }\n  });\n\n  it(\"can fuel up when stopped\", async () =\u003e {\n    await instance.stopEngine();\n    await instance.fuelUp(10);\n    const result = await instance.kilometersRemaining();\n    assert.equal(100, result, \"should have 100km\");\n  });\n\n  it(\"can't fuel up invalid amount\", async () =\u003e {\n    try {\n      await instance.fuelUp(100);\n      assert.ok(false, \"can't fuel up invalid amount\");\n    } catch {\n      return;\n    }\n  });\n\n  it(\"can't drive invalid amount\", async () =\u003e {\n    try {\n      await instance.startEngine();\n      await instance.drive(110);\n      assert.ok(false, \"can't drive invalid amount\");\n    } catch {\n      return;\n    }\n  });\n\n  it(\"can drive \", async () =\u003e {\n    await instance.stopEngine();\n    await instance.startEngine();\n    await instance.drive(100);\n    const result = await instance.kilometersRemaining();\n    assert.equal(0, result, \"should have 0km remaining\");\n  });\n\n  it(\"can fuel up when stopped 2\", async () =\u003e {\n    await instance.stopEngine();\n    await instance.fuelUp(25);\n    const result = await instance.kilometersRemaining();\n    assert.equal(250, result, \"should have 250km\");\n  });\n\n  it(\"can drive 2\", async () =\u003e {\n    await instance.startEngine();\n    await instance.drive(150);\n    const result = await instance.kilometersRemaining();\n    assert.equal(100, result, \"should have 100km remaining\");\n  });\n});\n"}},"spaceTime":"","submissionStatistics":{"correctCount":307,"failureCount":889},"testStrategy":"SANDBOX_ONLY","tests":[],"uid":"blockchain-road-trip","version":0,"video":{"annotations":[],"codeWalkthroughTime":null,"duration":0,"instructor":"","overviewTime":null,"vimeoId":"765853625"},"visualization":{"inputType":null,"outputType":null}},"difficulty":0,"instructor":"","name":"Blockchain Road Trip","releaseDate":"2022-05-24T00:00:00Z","type":"CODING_STANDARD","uid":"blockchain-road-trip"}]}
